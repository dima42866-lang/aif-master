# !/bin/bash
#
# Architect Installation Framework (version 1.6.3 - 17-Dec-2015)
#
# Written by Carl Duff for Architect Linux
#
# This program is free software, provided under the GNU General Public License
# as published by the Free Software Foundation. So feel free to copy, distribute,
# or modify it as you wish.
#



######################################################################
##																	##
##                   Installer Variables							##
##																	##
######################################################################

# Create a temporary file to store menu selections
ANSWER="/tmp/.aif"
ABSOLUT_FILENAME=`readlink -e "$0"`
filesdir=`dirname "$ABSOLUT_FILENAME"`
source $filesdir/list-pkg.forms
# Save retyping
VERSION="MAXIMALISIMUS Installation Framework 2.3"

# Installation
_mlpcrm=0 					# Once check the pacman-contrib at the rom system to uses in the rankmirror script 
KDE_INSTALLED=0      		# Has KDE been installed? Used for display manager option
GNOME_INSTALLED=0    		# Has Gnome been installed? Used for display manager option
LXDE_INSTALLED=0     		# Has LXDE been installed? Used for display manager option
LXQT_INSTALLED=0            # Has LXQT been installed? Used for display manager option
DM_INSTALLED=0       		# Has a display manager been installed?
COMMON_INSTALLED=0   		# Has the common-packages option been taken?
NM_INSTALLED=0       		# Has a network connection manager been installed and enabled?
AXI_INSTALLED=0             # Have the ALSA, Xorg, and xf86-input packages been installed?
BOOTLOADER="n/a"      		# Which bootloader has been installed?
EVOBOXFM=""           		# Which file manager has been selected for EvoBox?
EVOBOXIB=""           		# Which Internet Browser has been selected for EvoBox?
DM="n/a"              		# Which display manager has been installed?
KEYMAP="us"          		# Virtual console keymap. Default is "us"
XKBMAP="us"      	    	# X11 keyboard layout. Default is "us"
ZONE=""               		# For time
SUBZONE=""            		# For time
_h_c=0
_sethwclock=""
LOCALE="en_US.UTF-8"  		# System locale. Default is "en_US.UTF-8"
LTS=0                		# Has the LTS Kernel been installed?
GRAPHIC_CARD=""				# graphics card
INTEGRATED_GC=""			# Integrated graphics card for NVIDIA
NVIDIA_INST=0         		# Indicates if NVIDIA proprietary driver has been installed
SHOW_ONCE=0           		# Show de_wm information only once
_dm_menu_once=0 			# Dm menu once forms to search dm
_nm_once=0 					# Nm menu once forms to search nm
_gengen_once=0				# General once forms menu
_archivers_once=0			# Archivers once forms menu
_ttf_once=0					# TTF Theme once forms menu
_stpkg_once=0				# Standart packages once forms menu
_other_pkg_once=0			# Additional package once forms menu
_gengen_menu=""				# General packages save menu
archivers_menu=""			# Archivers save menu
_ttf_menu=""				# TTF Theme save menu
_standart_pkg_menu=""		# Standart package save menu
_other_pkg_menu=""			# Additional package save menu
_wifi_menu=""
_dm_desktop_menu=""
_list_dm_menu=""
_ldm_menu=""
_d_menu_once=0
_listdm_menu=""
_standart_pkg_menu=""
_multilib=0														# Multilib additional repositoryes to qestion
_user_local=""													# Forms User Locale in auto forms on Locale menu
_freefile="" 													# File of comand "free -h"
_swappiness="" 													# Variable to save parameter swappiness
_mem_file="/tmp/mem.conf" 										# file of info memory
_mem_msg_file="/tmp/msginfo.nfo" 								# Information on swappiness
_File_of_Config="/tmp/00-sysctl.conf" 							# Temp configuration swappiness
_real_dir_swpns="${MOUNTPOINT}/etc/sysctl.d/"					# Real dir to swappiness on config
_real_swappiness="${MOUNTPOINT}/etc/sysctl.d/00-sysctl.conf" 	# File of full path swappiness config to install system

declare -a _devices												# Array scan mnt mount devices variables declare
declare -a _device_menu											# Array menu form on scan mnt mount devices variables declare
DEVICES=""														# Array devices to clear
_isreserved=""													# Percentage to setup reserved block count on root
_rsrvd_file="/tmp/rsrvd.nfo"									# File information to reserved block count
_tmp_fstab="/tmp/tmp.fstab"										# File information on tmp folder to FSTAB
_once_shwram=0													# Once form memory information to mem file

_net_cntrl=0 													# Once run install qestion wireless programm
_shara_p=0 														# Once run install qestion shara programm
file_list_pkg="/tmp/flpkg.conf" 								# File to forms on new lists to pkgs

_wifi_menu_form=0												# Once forms wifi menu on wifi adapter your PC
_list_wifi_adapter_pkg=""										# Search package to wifi adapter driver
_wifi_menu=""													# Forms wifi menu to save

# Variables of keyboard parameters
_is_xkb=0
_skip=0
_switch_xkb=""
_indicate_xkd=""
_xkb_mdl=""
_xkb_list=""
_xkb_var=""
xkb_model=""
xkb_layout=""
xkb_variant=""
xkb_options=""

# Architecture
ARCHI=`uname -m`     		# Display whether 32 or 64 bit system
SYSTEM="Unknown"     		# Display whether system is BIOS or UEFI. Default is "unknown"
ROOT_PART=""          		# ROOT partition
UEFI_PART=""				# UEFI partition
UEFI_MOUNT=""         		# UEFI mountpoint
INST_DEV=""           		# Device where system has been installed
HIGHLIGHT=0           		# Highlight items for Main Menu
HIGHLIGHT_SUB=0	    		# Highlight items for submenus
SUB_MENU=""           		# Submenu to be highlighted

# Logical Volume Management
LVM=0                   	# Logical Volume Management Detected?
LUKS=0                  	# Luks Detected?
LVM_ROOT=0              	# LVM used for Root?
LVM_SEP_BOOT=0          	# 1 = Seperate /boot, 2 = seperate /boot & LVM
LVM_DISABLE=0           	# Option to allow user to deactive existing LVM
LVM_VG=""               	# Name of volume group to create
LVM_VG_MB=0             	# MB remaining of VG
LVM_LV_NAME=""          	# Name of LV to create
LV_SIZE_INVALID=0       	# Is LVM LV size entered valid?
VG_SIZE_TYPE=""         	# Is VG in Gigabytes or Megabytes?

# Installation
MOUNTPOINT="/mnt"       	# Installation
MOUNT_TYPE=""           	# "/dev/" for standard partitions, "/dev/mapper" for LVM
BTRFS=0                     # BTRFS used? "1" = btrfs alone, "2" = btrfs + subvolume(s)
BTRFS_OPTS="/tmp/.btrfs_opts" #BTRFS Mount options
BTRFS_MNT=""                # used for syslinux where /mnt is a btrfs subvolume

# Language Support
CURR_LOCALE="en_US.UTF-8"   # Default Locale
FONT=""                     # Set new font if necessary

# Edit Files
FILE=""                     # Which file is to be opened?
FILE2=""					# Which second file is to be opened?

######################################################################
##																	##
##                        Core Functions							##
##																	##
######################################################################

# Add locale on-the-fly and sets source translation file for installer
select_language() {
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Select Language " --menu "\nLanguage / sprache / taal / språk / lingua / idioma / nyelv / língua" 0 0 12 \
 	"1" $"English		(en)" \
 	"2" $"Italian 		(it)" \
 	"3" $"Russian 		(ru)" \
 	"4" $"Turkish 		(tr)" \
 	"5" $"Dutch 		(nl)" \
 	"6" $"Greek 		(el)" \
 	"7" $"Danish 		(da)" \
 	"8" $"Hungarian 	(hu)" \
 	"9" $"Portuguese 	(pt)" \
   "10" $"German	 	(de)" \
   "11" $"French		(fr)" \
   "12" $"Polish		(pl)" 2>${ANSWER}

	case $(cat ${ANSWER}) in
        "1") source ${filesdir}/english.trans
             CURR_LOCALE="en_US.UTF-8"
             ;;
        "2") source ${filesdir}/italian.trans
             CURR_LOCALE="it_IT.UTF-8"
             ;; 
        "3") source ${filesdir}/russian.trans
             CURR_LOCALE="ru_RU.UTF-8"
             FONT="LatKaCyrHeb-14.psfu"
             ;;
        "4") source ${filesdir}/turkish.trans
             CURR_LOCALE="tr_TR.UTF-8"
             FONT="LatKaCyrHeb-14.psfu"
             ;;
        "5") source ${filesdir}/dutch.trans
             CURR_LOCALE="nl_NL.UTF-8"
             ;;             
        "6") source ${filesdir}/greek.trans
             CURR_LOCALE="el_GR.UTF-8"
             FONT="iso07u-16.psfu"       
             ;;
        "7") source ${filesdir}/danish.trans
             CURR_LOCALE="da_DK.UTF-8"
             ;;   
        "8") source ${filesdir}/hungarian.trans
             CURR_LOCALE="hu_HU.UTF-8"
             FONT="lat2-16.psfu"
             ;;
        "9") source ${filesdir}/portuguese.trans
             CURR_LOCALE="pt_BR.UTF-8"    
             ;;      
       "10") source ${filesdir}/german.trans
             CURR_LOCALE="de_DE.UTF-8"
             ;;
       "11") source ${filesdir}/french.trans
             CURR_LOCALE="fr_FR.UTF-8"
             ;;
       "12") source ${filesdir}/polish.trans
             CURR_LOCALE="pl_PL.UTF-8"
             FONT="latarcyrheb-sun16"
             ;;
          *) exit 0
             ;;
    esac
        
    # Generate the chosen locale and set the language
    sed -i "s/#${CURR_LOCALE}/${CURR_LOCALE}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG=${CURR_LOCALE}
    [[ $FONT != "" ]] && setfont $FONT
}



# Check user is root, and that there is an active internet connection
# Seperated the checks into seperate "if" statements for readability.
check_requirements() {
	
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ChkTitle" --infobox "$_ChkBody" 0 0
  sleep 2
  
  if [[ `whoami` != "root" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RtFailTitle" --infobox "$_RtFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  if [[ ! $(ping -c 1 google.com) ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConFailTitle" --infobox "$_ConFailBody" 0 0
     sleep 2
     exit 1
  fi
  
  # This will only be executed where neither of the above checks are true.
  # The error log is also cleared, just in case something is there from a previous use of the installer.
  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ReqMetTitle" --infobox "$_ReqMetBody" 0 0
  sleep 2   
  clear
  echo "" > /tmp/.errlog
  pacman -Syy

}

# Adapted from AIS. Checks if system is made by Apple, whether the system is BIOS or UEFI,
# and for LVM and/or LUKS.
id_system() {
	
    # Apple System Detection
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    
    # BIOS or UEFI Detection
    if [[ -d "/sys/firmware/efi/" ]]; then
      # Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      SYSTEM="UEFI"
    else
      SYSTEM="BIOS"
    fi
         
    # Encryption (LUKS) Detection
    [[ $(lsblk -o TYPE | grep "crypt") == "" ]] && LUKS=0 || LUKS=1

}   
 

# Adapted from AIS. An excellent bit of code!
arch_chroot() {
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
}  

# If there is an error, display it, clear the log and then go back to the main menu (no point in continuing).
check_for_error() {

 if [[ $? -eq 1 ]] && [[ $(cat /tmp/.errlog | grep -i "error") != "" ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$(cat /tmp/.errlog)" 0 0
    echo "" > /tmp/.errlog
    main_menu_online
 fi
   
}

# Ensure that a partition is mounted
check_mount() {

    if [[ $(lsblk -o MOUNTPOINT | grep ${MOUNTPOINT}) == "" ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoMount" 0 0
       main_menu_online
    fi

}

# Ensure that Arch has been installed
check_base() {

    if [[ ! -e ${MOUNTPOINT}/etc ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ErrTitle" --msgbox "$_ErrNoBase" 0 0
        main_menu_online
    fi
    
}

# Simple code to show devices / partitions.
show_devices() {
     lsblk -o NAME,MODEL,TYPE,FSTYPE,SIZE,MOUNTPOINT | grep -v "loop" | grep -v "rom" | grep -v "arch_airootfs" > /tmp/.devlist
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevShowTitle" --textbox /tmp/.devlist 0 0
}

######################################################################
##																	##
##                 Configuration Functions							##
##																	##
######################################################################


# Adapted from AIS. Added option to allow users to edit the mirrorlist.
configure_mirrorlist() {

# Generate a mirrorlist based on the country chosen.	
mirror_by_country() {

 COUNTRY_LIST=""
 countries_list=("AU_Australia AT_Austria BY_Belarus BE_Belgium BR_Brazil BG_Bulgaria CA_Canada CL_Chile CN_China CO_Colombia CZ_Czech_Republic DK_Denmark EE_Estonia FI_Finland FR_France DE_Germany GB_United_Kingdom GR_Greece HU_Hungary IN_India IE_Ireland IL_Israel IT_Italy JP_Japan KZ_Kazakhstan KR_Korea LV_Latvia LU_Luxembourg MK_Macedonia NL_Netherlands NC_New_Caledonia NZ_New_Zealand NO_Norway PL_Poland PT_Portugal RO_Romania RU_Russia RS_Serbia SG_Singapore SK_Slovakia ZA_South_Africa ES_Spain LK_Sri_Lanka SE_Sweden CH_Switzerland TW_Taiwan TR_Turkey UA_Ukraine US_United_States UZ_Uzbekistan VN_Vietnam")

 for i in ${countries_list}; do
     COUNTRY_LIST="${COUNTRY_LIST} ${i} -"
 done
	
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorCntryTitle" --menu "$_MirrorCntryBody" 0 0 16 ${COUNTRY_LIST} 2>${ANSWER} || prep_menu
 COUNTRY_CODE=$(cat ${ANSWER} |sed 's/_.*//')

 URL="https://www.archlinux.org/mirrorlist/?country=${COUNTRY_CODE}&use_mirror_status=on"
 MIRROR_TEMP=$(mktemp --suffix=-mirrorlist)

 # Get latest mirror list and save to tmpfile
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorGenTitle" --infobox "$_MirrorGenBody" 0 0
  
 curl -so ${MIRROR_TEMP} ${URL} 2>/tmp/.errlog
 check_for_error
 sed -i 's/^#Server/Server/g' ${MIRROR_TEMP}
 nano ${MIRROR_TEMP}

 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_MirrorGenQ" 0 0

 if [[ $? -eq 0 ]];then
    mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
    mv -f ${MIRROR_TEMP} /etc/pacman.d/mirrorlist
    chmod +r /etc/pacman.d/mirrorlist
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --infobox "$_DoneMsg" 0 0
	sleep 2
 else
    prep_menu
 fi
}

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorlistTitle" \
    --menu "$_MirrorlistBody" 0 0 5 \
	"1" "$_MirrorbyCountry" \
	"2" "$_MirrorEdit" \
	"3" "$_MirrorRank" \
	"4" "$_MirrorRestore" \
	"5" "$_Back" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") mirror_by_country
             ;;
        "2") nano /etc/pacman.d/mirrorlist
             ;;
        "3") dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorRankTitle" --infobox "$_MirrorRankBody" 0 0
             if [[ $_mlpcrm == "0" ]]; then
				_mlpcrm=1
				clear
				info_search_pkg
				_list_rank_mirror=$(check_s_lst_pkg "${_rank_mirror[*]}")
				wait
				if [[ ${_list_rank_mirror[*]} != "" ]]; then
					pacman -Qs ${_list_rank_mirror[*]} 1>/dev/null 2>/dev/null
					[[ $? != "0" ]] && sudo pacman -S ${_list_rank_mirror[*]} --noconfirm
				fi
				wait
				clear
			fi	
			 cp -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
             rankmirrors -n 10 /etc/pacman.d/mirrorlist.backup > /etc/pacman.d/mirrorlist 2>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --infobox "$_DoneMsg" 0 0
			 sleep 2
             ;;
         "4") if [[ -e /etc/pacman.d/mirrorlist.orig ]]; then       
				 mv -f /etc/pacman.d/mirrorlist.orig /etc/pacman.d/mirrorlist
				 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --msgbox "$_MirrorRestDone" 0 0
		      else
		         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorNoneTitle" --msgbox "$_MirrorNoneBody" 0 0
		      fi
             ;;
          *) prep_menu
             ;;
    esac
    configure_mirrorlist
}

# virtual console keymap
set_keymap() { 
	
	KEYMAPS=""
    for i in $(ls -R /usr/share/kbd/keymaps | grep "map.gz" | sed 's/\.map.gz//g' | sort); do
        KEYMAPS="${KEYMAPS} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_KeymapTitle" \
    --menu "$_KeymapBody" 20 40 16 ${KEYMAPS} 2>${ANSWER} || prep_menu 
    KEYMAP=$(cat ${ANSWER})
    
	loadkeys $KEYMAP 2>/tmp/.errlog
    check_for_error

    echo -e "KEYMAP=${KEYMAP}\nFONT=${FONT}" > /tmp/vconsole.conf
  }

# Set keymap for X11
 set_xkbmap() { 	
	if [[ $_is_xkb -eq 0 ]]; then
		keymaps_xkb=("af_Afghani al_Albanian am_Armenian ara_Arabic at_German-Austria az_Azerbaijani ba_Bosnian bd_Bangla be_Belgian bg_Bulgarian br_Portuguese-Brazil bt_Dzongkha bw_Tswana by_Belarusian ca_French-Canada cd_French-DR-Congo ch_German-Switzerland cm_English-Cameroon cn_Chinese cz_Czech de_German dk_Danishee_Estonian epo_Esperanto es_Spanish et_Amharic fo_Faroese fi_Finnish fr_French gb_English-UK ge_Georgian gh_English-Ghana gn_French-Guinea gr_Greek hr_Croatian hu_Hungarian ie_Irish il_Hebrew iq_Iraqi ir_Persian is_Icelandic it_Italian jp_Japanese ke_Swahili-Kenya kg_Kyrgyz kh_Khmer-Cambodia kr_Korean kz_Kazakh la_Lao latam_Spanish-Lat-American lk_Sinhala-phonetic lt_Lithuanian lv_Latvian ma_Arabic-Morocco mao_Maori md_Moldavian me_Montenegrin mk_Macedonian ml_Bambara mm_Burmese mn_Mongolian mt_Maltese mv_Dhivehi ng_English-Nigeria nl_Dutch no_Norwegian np_Nepali ph_Filipino pk_Urdu-Pakistan pl_Polish pt_Portuguese ro_Romanian rs_Serbian ru_Russian se_Swedish si_Slovenian sk_Slovak sn_Wolof sy_Arabic-Syria th_Thai tj_Tajik tm_Turkmen tr_Turkish tw_Taiwanese tz_Swahili-Tanzania ua_Ukrainian us_English-US uz_Uzbek vn_Vietnamese za_English-S-Africa")
		
		_switch_xkb=("grp:toggle" "grp:ctrl_shift_toggle" "grp:alt_shift_toggle" "grp:ctrl_alt_toggle" "grp:lwin_toggle" "grp:rwin_toggle" "grp:lctrl_toggle" "grp:rctrl_toggle")
		
		_indicate_xkd=("grp_led:caps" "grp_led:num" "grp_led:scroll")
		
		for i in $(cat $filesdir/xkb-models.conf); do
			_xkb_mdl="${_xkb_mdl} ${i} -"
		done
		
		for i in ${keymaps_xkb[*]}; do
			_xkb_list="${_xkb_list} ${i} -"
		done	
		
		
		for i in $(cat $filesdir/xkb-variant.conf); do
			_xkb_var="${_xkb_var} ${i} -"
		done
		
		_is_xkb=1
	fi
	
	xkbmodel()
	{
		dialog --default-item 1 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_mdl_title" --menu "$_xkb_mdl_body" 0 0 11 ${_xkb_mdl} 2>${ANSWER} || set_xkbmap
		xkb_model=$(cat ${ANSWER})
	}
	xkblayout()
	{
		_xkb_w=""
		_xkb_u=""
		dialog --default-item 1 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_list_title" --menu "$_xkb_list1_body" 0 0 11 ${_xkb_list} 2>${ANSWER} || set_xkbmap
		_xkb_w=$(cat ${ANSWER} |sed 's/_.*//')
		
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_user_layout_title" --yesno "$_yesno_user_layout_body" 0 0
		if [[ $? -eq 0 ]]; then
			dialog --default-item 1 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_list_title" --menu "$_xkb_list2_body" 0 0 11 ${_xkb_list} 2>${ANSWER} || set_xkbmap
			_xkb_u=$(cat ${ANSWER} |sed 's/_.*//')
			[[ $_xkb_w == $_xkb_u ]] && xkb_layout="$_xkb_w" || xkb_layout="$_xkb_w,$_xkb_u"
		else
			xkb_layout="$_xkb_w"
		fi
	}
	xkbvariant()
	{
		dialog --default-item 1 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_var_title" --menu "$_xkb_var_body" 0 0 11 ${_xkb_var} 2>${ANSWER} || set_xkbmap
		xkb_variant=$(cat ${ANSWER})
	}
	xkboptions()
	{
		_sw=""
		_ind=""
		dialog --default-item 2 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_switch_title" --menu "$_xkb_switch_body" 0 0 8 \
			"1" $"Right Alt" \
			"2" $"Control+Shift" \
			"3" $"Alt+Shift" \
			"4" $"Control+Alt" \
			"5" $"Left Win" \
			"6" $"Right Win" \
			"7" $"Left Control" \
			"8" $"Right Control" 2>${ANSWER}
		var=$(cat ${ANSWER})
		var=$(($var-1))
		_sw=${_switch_xkb[$var]}
		dialog --default-item 2 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_indicate_title" --checklist "$_xkb_indicate_body" 0 0 3 \
			"1" "$_indicate_caps_lock" "off" \
			"2" "$_indicate_num_lock" "on" \
			"3" "$_indicate_scroll_lock" "off" 2>${ANSWER}
		# ${_indicate_xkd[0]}
		#_ind=$(cat ${ANSWER})
		# [[ $_ind == "" ]] && xkb_options="$_sw" || xkb_options="$_sw,$_ind"
		if [[ $(cat ${ANSWER}) == "" ]]; then
			xkb_options="$_sw"
		else
			counter=0
			for i in $(cat ${ANSWER}); do
				if [[ $counter -eq 0 ]]; then
					counter=1
					_tmp=$(($i-1))
					_ind=${_indicate_xkd[_tmp]}
				else
					_tmp=$(($i-1))
					_ind="${_ind},${_indicate_xkd[_tmp]}"
				fi
			done
			xkb_options="$_sw,$_ind"
		fi
	}
	fine_keyboard_conf()
	{
		[[ $xkb_layout == "" ]] && _skip=1
		[[ $xkb_model == "" ]] && _skip=1
		[[ $xkb_variant == "" ]] && _skip=1
		[[ $xkb_layout == "" ]] && xkb_layout="us"
		[[ $xkb_model == "" ]] && xkb_model="pc105"
		[[ $xkb_variant == "" ]] && xkb_variant="qwerty"
		if [[ $_skip == "1" ]]; then
			_xkb_info_body="\n$_inf2\n\n$_inf_l $xkb_layout\n$_inf_m $xkb_model\n$_inf_v $xkb_variant\n$_inf_o $xkb_options\n\n\n"
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_info_title" --msgbox "$_xkb_info_body" 0 0
			_skip=0
		fi
		echo "# /etc/X11/xorg.conf.d/00-keyboard.conf " > /tmp/00-keyboard.conf
		echo "# Read and parsed by systemd-localed. It's probably wise not to edit this file" >> /tmp/00-keyboard.conf
		echo -e -n "# manually too freely.\n" >> /tmp/00-keyboard.conf
		echo -e -n "Section \"InputClass\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tIdentifier \"system-keyboard\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tMatchIsKeyboard \"on\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tOption \"XkbLayout\" \"$xkb_layout\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tOption \"XkbModel\" \"$xkb_model\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tOption \"XkbVariant\" \"$xkb_variant\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "\tOption \"XKbOptions\" \"$xkb_options\"\n" >> /tmp/00-keyboard.conf
		echo -e -n "EndSection\n" >> /tmp/00-keyboard.conf
	}
	
	if [[ $SUB_MENU != "set_xkbmap" ]]; then
	   SUB_MENU="set_xkbmap"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
	dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_xkb_menu_title" --menu "$_xkb_menu_body" 0 0 5 \
 	"1" "* $_xkb_layout_menu" \
	"2" "$_xkb_model_menu" \
	"3" "$_xkb_variant_menu" \
	"4" "$_xkb_options_menu" \
	"5" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") xkblayout
         ;;
    "2") dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_xkb_model_title" --yesno "$_yesno_xkb_model_body" 0 0
		if [[ $? -eq 0 ]]; then
			xkbmodel
		else
			xkb_model="pc105"
		fi
         ;;
	"3") dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_variant_title" --yesno "$_yesno_varinant_body" 0 0
		if [[ $? -eq 0 ]]; then
			xkbvariant
		else
			xkb_variant="winkeys"
		fi
		;;
	"4") dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_options_title" --yesno "$_yesno_options_body" 0 0
		if [[ $? -eq 0 ]]; then
			xkboptions
		else
			xkb_options="grp:ctrl_shift_toggle,grp_led:num"
		fi
		;;
      *) fine_keyboard_conf 
		config_base_menu
         ;;
    esac

	set_xkbmap
}

# locale array generation code adapted from the Manjaro 0.8 installer
set_locale() {

  LOCALES=""	
  for i in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do
      LOCALES="${LOCALES} ${i} -"
  done

  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LocateTitle" --menu "$_localeBody" 0 0 16 ${LOCALES} 2>${ANSWER} || config_base_menu 
  LOCALE=$(cat ${ANSWER})
    
  # _KEYMAP=$(echo "${LOCALE}" | sed 's/_.*//')
  _KEYMAP=""
   for i in $(ls -R /usr/share/kbd/keymaps | grep "map.gz" | sed 's/\.map.gz//g' | sort); do
    _KEYMAP="${_KEYMAP} ${i} -"
   done

   clear
   
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LocaleConsoleTitle" \
  --menu "$_LocaleConsoleBody" 20 40 16 ${_KEYMAP} 2>${ANSWER} || prep_menu 
   _KEYMAP=$(cat ${ANSWER})
   
  _user_local=$(echo "${LOCALE}" | sed 's/_.*//')
  
  echo "LANG=\"${LOCALE}\"" > ${MOUNTPOINT}/etc/locale.conf
  echo "LC_MESSAGES=\"${LOCALE}\"" >> ${MOUNTPOINT}/etc/locale.conf
  sed -i "s/#${LOCALE}/${LOCALE}/" ${MOUNTPOINT}/etc/locale.gen 2>/tmp/.errlog
  arch_chroot "loadkeys ${_KEYMAP}" >/dev/null 2>>/tmp/.errlog
  echo "LOCALE=\"${LOCALE}\"" > ${MOUNTPOINT}/etc/vconsole.conf
  echo "KEYMAP=\"${_KEYMAP}\"" >> ${MOUNTPOINT}/etc/vconsole.conf
  [[ ${_KEYMAP} =~ ^(ru) ]] && FONT="cyr-sun16"
  if [[ $FONT != "" ]]; then
	echo "FONT=\"${FONT}\"" >> ${MOUNTPOINT}/etc/vconsole.conf
	echo "CONSOLEFONT=\"${FONT}\"" >> ${MOUNTPOINT}/etc/vconsole.conf
	arch_chroot "setfont ${FONT}" >/dev/null 2>>/tmp/.errlog
  else
	echo "FONT=\"cyr-sun16\"" >> ${MOUNTPOINT}/etc/vconsole.conf
	echo "CONSOLEFONT=\"cyr-sun16\"" >> ${MOUNTPOINT}/etc/vconsole.conf
	arch_chroot "setfont cyr-sun16" >/dev/null 2>>/tmp/.errlog
  fi
  echo "USECOLOR=\"yes\"" >> ${MOUNTPOINT}/etc/vconsole.conf
  arch_chroot "locale-gen" >/dev/null 2>>/tmp/.errlog
  arch_chroot "export Lang=\"${LOCALE}\"" >/dev/null 2>>/tmp/.errlog
  [[ ${ZONE[*]} != "" ]] && [[ ${SUBZONE[*]} != "" ]] && echo "TIMEZONE=\"${ZONE}/${SUBZONE}\"" >> ${MOUNTPOINT}/etc/vconsole.conf
  [[ ${_sethwclock[*]} != "" ]] && echo "HARDWARECLOCK=\"${_sethwclock}\"" >> ${MOUNTPOINT}/etc/vconsole.conf
  echo "CONSOLEMAP=\"\"" >> ${MOUNTPOINT}/etc/vconsole.conf
  check_for_error
}

# Set Zone and Sub-Zone
set_timezone() {

    ZONE=""
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "/" | sed "s/\/.*//g" | sort -ud); do
      ZONE="$ZONE ${i} -"
    done
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeZTitle" --menu "$_TimeZBody" 0 0 10 ${ZONE} 2>${ANSWER} || config_base_menu
     ZONE=$(cat ${ANSWER}) 
    
     SUBZONE=""
     for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "${ZONE}/" | sed "s/${ZONE}\///g" | sort -ud); do
        SUBZONE="$SUBZONE ${i} -"
     done
         
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_TimeSubZTitle" --menu "$_TimeSubZBody" 0 0 11 ${SUBZONE} 2>${ANSWER} || config_base_menu
     SUBZONE=$(cat ${ANSWER}) 
    
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_TimeZQ ${ZONE}/${SUBZONE} ?" 0 0 
     
     if [[ $? -eq 0 ]]; then
        arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" 2>/tmp/.errlog
        check_for_error
     else
        config_base_menu
     fi
}

set_hw_clock() {
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HwCTitle" \
    --menu "$_HwCBody" 0 0 2 \
 	"1" "$_HwCUTC" \
	"2" "$_HwLocal" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") arch_chroot "hwclock --systohc --utc"  2>/tmp/.errlog
			_sethwclock="UTC"
             ;;
        "2") arch_chroot "hwclock --systohc --localtime" 2>/tmp/.errlog
			_sethwclock="localtime"
             ;;
          *) config_base_menu
             ;;
     esac	
     
     check_for_error
}

# Adapted from AIS. As with some other functions, decided that keeping the numbering for options
# was worth repeating portions of code.
generate_fstab() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FstabTitle" \
    --menu "$_FstabBody" 0 0 3 \
	"1" "$_FstabDev" \
	"2" "$_FstabLabel" \
	"3" "$_FstabUUID" 2>${ANSWER}

    case $(cat ${ANSWER}) in
        "1") genfstab -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "2") genfstab -L -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             ;;
        "3") if [[ $SYSTEM == "UEFI" ]]; then
                genfstab -t PARTUUID -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             else 
                genfstab -U -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
             fi
             ;;
          *) config_base_menu
             ;;
    esac

    check_for_error

    [[ -f ${MOUNTPOINT}/swapfile ]] && sed -i "s/\\${MOUNTPOINT}//" ${MOUNTPOINT}/etc/fstab

}

# Adapted from AIS.
set_hostname() {

   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_HostNameTitle" --inputbox "$_HostNameBody" 0 0 "arch" 2>${ANSWER} || config_base_menu
   HOST_NAME=$(cat ${ANSWER})

   echo "$HOST_NAME" > ${MOUNTPOINT}/etc/hostname 2>/tmp/.errlog
   check_for_error
   echo -e "#<ip-address>\t<hostname.domain.org>\t<hostname>\n127.0.0.1\tlocalhost.localdomain\tlocalhost\t${HOST_NAME}\n::1\tlocalhost.localdomain\tlocalhost\t${HOST_NAME}" > ${MOUNTPOINT}/etc/hosts
}

# Adapted and simplified from the Manjaro 0.8 and Antergos 2.0 installers
set_root_password() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD=$(cat ${ANSWER})
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtTitle" --clear --insecure --passwordbox "$_PassRtBody2" 0 0 2> ${ANSWER} || config_user_menu
    PASSWD2=$(cat ${ANSWER})
    
    if [[ $PASSWD == $PASSWD2 ]]; then 
       echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
       arch_chroot "passwd root" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
       rm /tmp/.passwd
       check_for_error
    else
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassRtErrTitle" --msgbox "$_PassRtErrBody" 0 0
       set_root_password
    fi

}

# Originally adapted from the Antergos 2.0 installer
create_new_user() {

        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrBody" 0 0 "" 2>${ANSWER} || config_user_menu
        USER=$(cat ${ANSWER})
        
        # Loop while user name is blank, has spaces, or has capital letters in it.
         while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrTitle" --inputbox "$_NUsrErrBody" 0 0 "" 2>${ANSWER} || config_user_menu
              USER=$(cat ${ANSWER})
        done
        
        # Enter password. This step will only be reached where the loop has been skipped or broken.
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD=$(cat ${ANSWER}) 
    
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
        PASSWD2=$(cat ${ANSWER}) 
    
        # loop while passwords entered do not match.
        while [[ $PASSWD != $PASSWD2 ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrErrTitle" --msgbox "$_PassNUsrErrBody" 0 0
              
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD=$(cat ${ANSWER}) 
    
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PassNUsrTitle" --clear --insecure --passwordbox "$_PassNUsrBody2 $USER\n\n" 0 0 2> ${ANSWER} || config_user_menu
              PASSWD2=$(cat ${ANSWER}) 
        done      
    
        # create new user. This step will only be reached where the password loop has been skipped or broken.  
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NUsrSetTitle" --infobox "$_NUsrSetBody" 0 0
        sleep 2
        # Create the user, set password, then remove temporary password file
        arch_chroot "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash" 2>/tmp/.errlog
        check_for_error
        echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
        arch_chroot "passwd ${USER}" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
        rm /tmp/.passwd
        check_for_error
        # Set up basic configuration files and permissions for user
        arch_chroot "cp /etc/skel/.bashrc /home/${USER}"
        arch_chroot "chown -R ${USER}:users /home/${USER}"
        sed -i '/%wheel ALL=(ALL) ALL/s/^#//' ${MOUNTPOINT}/etc/sudoers
      
}

run_mkinitcpio() {
	
  clear
  
  # If $LVM is being used, add the lvm2 hook
  [[ $LVM -eq 1 ]] && sed -i 's/block filesystems/block lvm2 filesystems/g' ${MOUNTPOINT}/etc/mkinitcpio.conf
    
  # Amend command depending on whether LTS kernel was installed or not
  [[ $LTS -eq 1 ]] && arch_chroot "mkinitcpio -P" 2>/tmp/.errlog || arch_chroot "mkinitcpio -P" 2>/tmp/.errlog
  check_for_error
 
}

######################################################################
##																	##
##            System and Partitioning Functions						##
##																	##
######################################################################



# Unmount partitions.
umount_partitions(){
	
  MOUNTED=""
  MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
  swapoff -a
  
  for i in ${MOUNTED[@]}; do
      umount $i >/dev/null 2>>/tmp/.errlog
  done
  
  check_for_error

}

# Adapted from AIS
confirm_mount() {
    if [[ $(mount | grep $1) ]]; then   
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusSucc" 0 0
      sleep 2
      PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
      NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusFail" 0 0
      sleep 2
      prep_menu
    fi
}

# btrfs specific for subvolumes
confirm_mount_btrfs() {
    if [[ $(mount | grep $1) ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusSucc\n$(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL}\n\n" 0 0
      sleep 2
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntStatusTitle" --infobox "$_MntStatusFail" 0 0
      sleep 2
      prep_menu
    fi
}

# Adapted from AIS. However, this does not assume that the formatted device is the Root
# installation device; more than one device may be formatted. This is now set in the
# mount_partitions function, when the Root is chosen.
select_device() {
	
    DEVICE=""
    devices_list=$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd\|nvme\|mmc');
    
    for i in ${devices_list[@]}; do
        DEVICE="${DEVICE} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevSelTitle" --menu "$_DevSelBody" 0 0 4 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(cat ${ANSWER})
 
  }

# Same as above, but goes to install_base_menu instead where cancelling, and otherwise installs Grub.
select_grub_device() {
	
    GRUB_DEVICE=""
    grub_devices_list=$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd');
    
    for i in ${grub_devices_list[@]}; do
        GRUB_DEVICE="${GRUB_DEVICE} ${i} -"
    done
    
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevSelGrubTitle" --menu "$_DevSelBody" 0 0 4 ${GRUB_DEVICE} 2>${ANSWER} || install_base_menu
    GRUB_DEVICE=$(cat ${ANSWER})
    clear
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
    sleep 1
    arch_chroot "grub-install --target=i386-pc --recheck ${GRUB_DEVICE}" 2>/tmp/.errlog
    check_for_error
 
  }

# Originally adapted from AIS.
create_partitions(){

# This only creates the minimum number of partition(s) necessary. Users wishing for other schemes will
# have to learn to use a partitioning application.
auto_partition(){

# Hooray for tac! Deleting partitions in reverse order deals with logical partitions easily.
delete_partitions(){
	
	parted -s ${DEVICE} print | awk '/^ / {print $1}' > /tmp/.del_parts
	
	for del_part in $(tac /tmp/.del_parts); do
		parted -s ${DEVICE} rm ${del_part} 2>/tmp/.errlog
		check_for_error
	done


}
 
 # Identify the partition table
 part_table=$(parted -s ${DEVICE} print | grep -i 'partition table' | awk '{print $3}')

 # Autopartition for BIOS systems 
 if [[ $SYSTEM == "BIOS" ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Auto-Partition (BIOS/MBR) " --yesno "$_AutoPartBody1 $DEVICE $_AutoPartBIOSBody2" 0 0
	
	if [[ $? -eq 0 ]]; then
	    delete_partitions
	    if [[ $part_table != "msdos" ]]; then
		   parted -s ${DEVICE} mklabel msdos 2>/tmp/.errlog
		   check_for_error
		fi
		parted -s ${DEVICE} mkpart primary ext3 1MiB 100% 2>/tmp/.errlog	
		parted -s ${DEVICE} set 1 boot on 2>>/tmp/.errlog
		check_for_error
        echo -e "Partition Scheme:\n" > /tmp/.devlist
        lsblk ${DEVICE} -o NAME,TYPE,FSTYPE,SIZE > /tmp/.devlist
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "" --textbox /tmp/.devlist 0 0
    else
        create_partitions
    fi
 
 # Autopartition for UEFI systems   
 else
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Auto-Partition (UEFI/GPT) " --yesno "$_AutoPartBody1 $DEVICE $_AutoPartUEFIBody2" 0 0
	
	if [[ $? -eq 0 ]]; then
	    delete_partitions
	    if [[ $part_table != "gpt" ]]; then
		   parted -s ${DEVICE} mklabel gpt 2>/tmp/.errlog
		   check_for_error
		fi
		parted -s ${DEVICE} mkpart ESP fat32 1MiB 513MiB 2>/tmp/.errlog
		parted -s ${DEVICE} set 1 boot on 2>>/tmp/.errlog
		parted -s ${DEVICE} mkpart primary ext3 513MiB 100% 2>>/tmp/.errlog
		echo -e "Partition Scheme:\n" > /tmp/.devlist
        lsblk ${DEVICE} -o NAME,TYPE,FSTYPE,SIZE >> /tmp/.devlist
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "" --textbox /tmp/.devlist 0 0
    else
		create_partitions
    fi
    
 fi

}

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PartToolTitle" \
    --menu "$_PartToolBody" 0 0 6 \
    "1" $"Auto Partition (BIOS & UEFI)" \
 	"2" $"Parted (BIOS & UEFI)" \
	"3" $"CFDisk (BIOS/MBR)" \
	"4" $"CGDisk (UEFI/GPT)" \
	"5" $"FDisk  (BIOS & UEFI)" \
	"6" $"GDisk  (UEFI/GPT)" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") auto_partition
             ;;
        "2") clear
             parted ${DEVICE}
             ;;
        "3") cfdisk ${DEVICE}
             ;;
        "4") cgdisk ${DEVICE}
             ;;       
        "5") clear
             fdisk ${DEVICE}
             ;;
        "6") clear
             gdisk ${DEVICE}
             ;;
          *) prep_menu
             ;;
    esac  	
}	

# find all available partitions and generate a list of them
# This also includes partitions on different devices.
find_partitions() {

	PARTITIONS=""
	NUMBER_PARTITIONS=0
    partition_list=$(lsblk -l | grep 'part\|lvm' | sed 's/[\t ].*//' | sort -u)
	
    for i in ${partition_list[@]}; do
        PARTITIONS="${PARTITIONS} ${i} -"
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done
    
    # Deal with incorrect partitioning
    if [[ $NUMBER_PARTITIONS -lt 2 ]] && [[ $SYSTEM == "UEFI" ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_UefiPartErrTitle" --msgbox "$_UefiPartErrBody" 0 0
        create_partitions
    fi
    
    if [[ $NUMBER_PARTITIONS -eq 0 ]] && [[ $SYSTEM == "BIOS" ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_BiosPartErrTitle" --msgbox "$_BiosPartErrBody" 0 0	
        create_partitions
    fi
}

# Set static list of filesystems rather than on-the-fly. Partially as most require additional flags, and 
# partially because some don't seem to be viable.
select_filesystem(){

# Clear special FS type flags
BTRFS=0

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FSTitle" \
    --menu "$_FSBody" 0 0 12 \
 	"1" "$_FSSkip" \
 	"2" $"btrfs" \
	"3" $"ext2" \
 	"4" $"ext3" \
	"5" $"ext4" \
	"6" $"f2fs" \
	"7" $"jfs" \
 	"8" $"nilfs2" \
	"9" $"ntfs" \
	"10" $"reiserfs" \
 	"11" $"vfat" \
	"12" $"xfs" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") FILESYSTEM="skip"
             ;;
        "2") FILESYSTEM="mkfs.btrfs -f"
             modprobe btrfs
             
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle" --yesno "$_btrfsSVBody" 0 0
             if [[ $? -eq 0 ]];then
				BTRFS=2
		     else
                BTRFS=1
             fi
             
             ;;
        "3") FILESYSTEM="mkfs.ext2 -F"
             ;;
        "4") FILESYSTEM="mkfs.ext3 -F"
             ;;            
        "5") FILESYSTEM="mkfs.ext4 -F"
             ;;
        "6") FILESYSTEM="mkfs.f2fs"
             modprobe f2fs
             ;;
        "7") FILESYSTEM="mkfs.jfs -q"
             ;;
        "8") FILESYSTEM="mkfs.nilfs2 -f"
             ;;  
        "9") FILESYSTEM="mkfs.ntfs -q"
             ;;  
        "10") FILESYSTEM="mkfs.reiserfs -f -f"
             ;;  
       "11") FILESYSTEM="mkfs.vfat -F32"
             ;;  
       "12") FILESYSTEM="mkfs.xfs -f"
             ;;      
          *) prep_menu
             ;;
    esac

  }
  
mount_partitions() {

# function created to save repetition of code. Checks and determines if standard partition or LVM LV,
# and sets the prefix accordingly.
set_mount_type() {

[[ $(echo ${PARTITION} | grep 'sd\|hd\|vd[a-z][1-99]') != "" ]] && MOUNT_TYPE="/dev/" || MOUNT_TYPE="/dev/mapper/"
	
}

btrfs_subvols() {

 BTRFS_MSUB_VOL=""
 BTRFS_OSUB_VOL=""
 BTRFS_MNT=""
 BTRFS_VOL_LIST="/tmp/.vols"
 echo "" > ${BTRFS_VOL_LIST}
 BTRFS_OSUB_NUM=1
 
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle" --inputbox "$_btrfsMSubBody1 ${MOUNTPOINT}${MOUNT} $_btrfsMSubBody2" 0 0 "" 2>${ANSWER} || select_filesystem
 BTRFS_MSUB_VOL=$(cat ${ANSWER})
 # if root, then create boot flag for syslinux, systemd-boot and rEFInd bootloaders	
 [[ ${MOUNT} == "" ]] && BTRFS_MNT="rootflags=subvol="$BTRFS_MSUB_VOL

 # Loop while subvolume is blank or has spaces.
 while [[ ${#BTRFS_MSUB_VOL} -eq 0 ]] || [[ $BTRFS_MSUB_VOL =~ \ |\' ]]; do
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVErrTitle" --inputbox "$_btrfsSVErrBody" 0 0 "" 2>${ANSWER} || select_filesystem
       BTRFS_MSUB_VOL=$(cat ${ANSWER})
       # if root, then create flag for syslinux, systemd-boot and rEFInd bootloaders
       [[ ${MOUNT} == "" ]] && BTRFS_MNT="rootflags=subvol="$BTRFS_MSUB_VOL
 done
 
 # change dir depending on whether root partition or not
 [[ ${MOUNT} == "" ]] && cd ${MOUNTPOINT} || cd ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 btrfs subvolume create ${BTRFS_MSUB_VOL} 2>>/tmp/.errlog
 cd
 umount ${MOUNT_TYPE}${PARTITION} 2>>/tmp/.errlog
 check_for_error
 
 # Get any mount options and mount
 btrfs_mount_opts
 if [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	[[ ${MOUNT} == "" ]] && mount -o $(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL} ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT} 2>/tmp/.errlog || mount -o $(cat ${BTRFS_OPTS})",subvol="${BTRFS_MSUB_VOL} ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 else
    [[ ${MOUNT} == "" ]] &&	mount -o "subvol="${BTRFS_MSUB_VOL} ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT} 2>/tmp/.errlog || mount -o "subvol="${BTRFS_MSUB_VOL} ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 fi
 
 # Check for error and confirm successful mount
 check_for_error  
 [[ ${MOUNT} == "" ]] && confirm_mount_btrfs ${MOUNTPOINT} || confirm_mount_btrfs ${MOUNTPOINT}${MOUNT}
 
 # Now create the subvolumes   
 [[ ${MOUNT} == "" ]] && cd ${MOUNTPOINT} || cd ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
 check_for_error
 
 # Loop while the termination character has not been entered
 while [[ $BTRFS_OSUB_VOL != "*" ]]; do
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVTitle ($BTRFS_MSUB_VOL) " --inputbox "$_btrfsSVBody1 $BTRFS_OSUB_NUM $_btrfsSVBody2 $BTRFS_MSUB_VOL.$_btrfsSVBody3 $(cat ${BTRFS_VOL_LIST})" 0 0 "" 2>${ANSWER} || select_filesystem
	BTRFS_OSUB_VOL=$(cat ${ANSWER})	

    # Loop while subvolume is blank or has spaces.
    while [[ ${#BTRFS_OSUB_VOL} -eq 0 ]] || [[ $BTRFS_SUB_VOL =~ \ |\' ]]; do
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsSVErrTitle ($BTRFS_MSUB_VOL) " --inputbox "$_btrfsSVErrBody ($BTRFS_OSUB_NUM)." 0 0 "" 2>${ANSWER} || select_filesystem
       BTRFS_OSUB_VOL=$(cat ${ANSWER})
    done
 
    btrfs subvolume create ${BTRFS_OSUB_VOL} 2>/tmp/.errlog 
    check_for_error
    BTRFS_OSUB_NUM=$(( BTRFS_OSUB_NUM + 1 ))
    echo $BTRFS_OSUB_VOL" " >> ${BTRFS_VOL_LIST}
 done
 
 # Show the subvolumes created
 echo -e "btrfs subvols:\n" > /tmp/.subvols
 ls  >> /tmp/.subvols
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --textbox /tmp/.subvols 0 0
 cd
}

# This function allows for btrfs-specific mounting options to be applied. Written as a seperate function
# for neatness.
btrfs_mount_opts() {

	echo "" > ${BTRFS_OPTS}

	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsMntTitle" --checklist "$_btrfsMntBody" 0 0 16 \
	"1" "autodefrag" off \
	"2" "compress=zlib" off \
	"3" "compress=lzo" off \
	"4" "compress=no" off \
	"5" "compress-force=zlib" off \
	"6" "compress-force=lzo" off \
	"7" "discard" off \
	"8" "noacl" off \
    "9" "noatime" off \
   "10" "nodatasum" off \
   "11" "nospace_cache" off \
   "12" "recovery" off \
   "13" "skip_balance" off \
   "14" "space_cache" off  \
   "15" "ssd" off \
   "16" "ssd_spread" off 2>${BTRFS_OPTS}
 
   # Double-digits first       
   sed -i 's/10/nodatasum,/' ${BTRFS_OPTS}
   sed -i 's/11/nospace_cache,/' ${BTRFS_OPTS}
   sed -i 's/12/recovery,/' ${BTRFS_OPTS}
   sed -i 's/13/skip_balance,/' ${BTRFS_OPTS}
   sed -i 's/14/space_cache,/' ${BTRFS_OPTS}
   sed -i 's/15/ssd,/' ${BTRFS_OPTS}
   sed -i 's/16/ssd_spread,/' ${BTRFS_OPTS}
   # then single digits
   sed -i 's/1/autodefrag,/' ${BTRFS_OPTS}
   sed -i 's/2/compress=zlib,/' ${BTRFS_OPTS}
   sed -i 's/3/compress=lzo,/' ${BTRFS_OPTS}
   sed -i 's/4/compress=no,/' ${BTRFS_OPTS}
   sed -i 's/5/compress-force=zlib,/' ${BTRFS_OPTS}
   sed -i 's/6/compress-force=lzo,/' ${BTRFS_OPTS}
   sed -i 's/7/noatime,/' ${BTRFS_OPTS}
   sed -i 's/8/noacl,/' ${BTRFS_OPTS}
   sed -i 's/9/noatime,/' ${BTRFS_OPTS}
   # Now clean up the file
   sed -i 's/ //g' ${BTRFS_OPTS}
   sed -i '$s/,$//' ${BTRFS_OPTS}

   
   if [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	  dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_btrfsMntTitle" --yesno "$_btrfsMntConfBody $(cat $BTRFS_OPTS)\n" 0 0 
	  [[ $? -eq 1 ]] && btrfs_mount_opts
   fi  

}

    # LVM Detection. If detected, activate.
    detect_lvm
    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --infobox "$_LvmDetBody2" 0 0
       sleep 2   
       modprobe dm-mod 2>/tmp/.errlog
       check_for_error
       vgscan >/dev/null 2>&1
       vgchange -ay >/dev/null 2>&1
    fi

	# Ensure partitions are unmounted (i.e. where mounted previously), and then list available partitions
    umount_partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelRootTitle" --menu "$_SelRootBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || prep_menu
	PARTITION=$(cat ${ANSWER})
    ROOT_PART=${PARTITION}
    set_mount_type
    
    # This is to identify the device for Grub installations.
    if [[ $MOUNT_TYPE == "/dev/" ]]; then   
       LVM_ROOT=0
       INST_DEV=${MOUNT_TYPE}$(cat ${ANSWER} | sed 's/[0-9]*//g')
    else
       LVM_ROOT=1
    fi
    	
	select_filesystem
	[[ $FILESYSTEM != "skip" ]] && ${FILESYSTEM} ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
	check_for_error
	
	# Make the root directory
	mkdir -p ${MOUNTPOINT} 2>/tmp/.errlog

    # If btrfs without subvolumes has been selected, get the mount options
    [[ $BTRFS -eq 1 ]] && btrfs_mount_opts
    
    # If btrfs has been selected without subvolumes - and at least one btrfs mount option selected - then
	# mount with options. Otherwise, basic mount.
	if [[ $BTRFS -eq 1 ]] && [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
	   mount -o $(cat ${BTRFS_OPTS}) ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT} 2>>/tmp/.errlog
	else
	   mount ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT} 2>>/tmp/.errlog
    fi
	  
	# Check for error, confirm mount, and deal with BTRFS with subvolumes if applicable  
	check_for_error
    confirm_mount ${MOUNTPOINT}
    [[ $BTRFS -eq 2 ]] && btrfs_subvols
	
	# Identify and create swap, if applicable
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelSwpTitle" --menu "$_SelSwpBody" 0 0 4 "$_SelSwpNone" $"-" "$_SelSwpFile" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu  
    if [[ $(cat ${ANSWER}) != "$_SelSwpNone" ]]; then    
       PARTITION=$(cat ${ANSWER})
       
       if [[ $PARTITION == "$_SelSwpFile" ]]; then
          total_memory=`grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//'`
          fallocate -l ${total_memory}M ${MOUNTPOINT}/swapfile >/dev/null 2>/tmp/.errlog
          check_for_error
          chmod 600 ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          mkswap ${MOUNTPOINT}/swapfile >/dev/null 2>&1
          swapon ${MOUNTPOINT}/swapfile >/dev/null 2>&1
       else
          set_mount_type
          # Only create a swap if not already in place
          [[ $(lsblk -o FSTYPE  ${MOUNT_TYPE}${PARTITION} | grep -i "swap") != "swap" ]] &&  mkswap  ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
          swapon  ${MOUNT_TYPE}${PARTITION} >/dev/null 2>>/tmp/.errlog
          check_for_error
          # Since a partition was used, remove that partition from the list
          PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
          NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
       fi
    fi
    
    # Extra Step for VFAT UEFI Partition. This cannot be in an LVM container.
    if [[ $SYSTEM == "UEFI" ]]; then
    
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SelUefiTitle" --menu "$_SelUefiBody" 0 0 4 ${PARTITIONS} 2>${ANSWER} || config_base_menu  
       PARTITION=$(cat ${ANSWER})
       UEFI_PART=$"/dev/"${PARTITION}
       
       # If it is already a fat/vfat partition...
       if [[ $(fsck -N /dev/$PARTITION | grep fat) ]]; then
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_FormUefiTitle" --yesno "$_FormUefiBody $PARTITION $_FormUefiBody2" 0 0 && mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>/tmp/.errlog
       else 
          mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>/tmp/.errlog
       fi
       check_for_error
       
       # Inform users of the mountpoint options and consequences       
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MntUefiTitle" --menu "$_MntUefiBody"  0 0 2 \
 	   "1" $"/boot" \
	   "2" $"/boot/efi" 2>${ANSWER}
       
       case $(cat ${ANSWER}) in
        "1") UEFI_MOUNT="/boot"
             ;;
        "2") UEFI_MOUNT="/boot/efi"
             ;;
          *) config_base_menu
             ;;
       esac
       
       mkdir -p ${MOUNTPOINT}${UEFI_MOUNT} 2>/tmp/.errlog
       mount $"/dev/"${PARTITION} ${MOUNTPOINT}${UEFI_MOUNT} 2>>/tmp/.errlog
       check_for_error
       confirm_mount ${MOUNTPOINT}${UEFI_MOUNT}     
       
    fi
    
    # All other partitions
       while [[ $NUMBER_PARTITIONS > 0 ]]; do 
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtPartTitle" --menu "$_ExtPartBody" 0 0 4 "$_Done" $"-" ${PARTITIONS} 2>${ANSWER} || config_base_menu 
             PARTITION=$(cat ${ANSWER})
             set_mount_type
             
             if [[ $PARTITION == ${_Done} ]]; then
                break;
             else
                MOUNT=""
                
                select_filesystem 
                [[ $FILESYSTEM != "skip" ]] && ${FILESYSTEM} ${MOUNT_TYPE}${PARTITION} >/dev/null 2>/tmp/.errlog
	            check_for_error
	            
                # Don't give /boot as an example for UEFI systems!
                if [[ $SYSTEM == "UEFI" ]]; then
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                else
                   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                fi
                MOUNT=$(cat ${ANSWER})
                
                # loop if the mountpoint specified is incorrect (is only '/', is blank, or has spaces). 
                while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
                      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtErrTitle" --msgbox "$_ExtErrBody" 0 0
                      
                      # Don't give /boot as an example for UEFI systems!
                      if [[ $SYSTEM == "UEFI" ]]; then
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyUefi" 0 0 "/" 2>${ANSWER} || config_base_menu
                      else
                         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ExtNameTitle $PARTITON " --inputbox "$_ExtNameBodyBios" 0 0 "/" 2>${ANSWER} || config_base_menu
                      fi
                      MOUNT=$(cat ${ANSWER})                     
                done

                # Create directory and mount. This step will only be reached where the loop has been skipped or broken.
                mkdir -p ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
                
                # If btrfs without subvolumes has been selected, get the mount options
                [[ $BTRFS -eq 1 ]] && btrfs_mount_opts
    
                # If btrfs has been selected without subvolumes - and at least one btrfs mount option selected - then
	            # mount with options. Otherwise, basic mount.
	            if [[ $BTRFS -eq 1 ]] && [[ $(cat ${BTRFS_OPTS}) != "" ]]; then
					mount -o $(cat ${BTRFS_OPTS}) ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
				else
					mount ${MOUNT_TYPE}${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
				fi
	  
				# Check for error, confirm mount, and deal with BTRFS with subvolumes if applicable  
				check_for_error
				confirm_mount ${MOUNTPOINT}${MOUNT}
				[[ $BTRFS -eq 2 ]] && btrfs_subvols
                
                # Determine if a seperate /boot is used, and if it is LVM or not
                LVM_SEP_BOOT=0
                if [[ $MOUNT == "/boot" ]]; then
                   [[ $MOUNT_TYPE == "/dev/" ]] && LVM_SEP_BOOT=1 || LVM_SEP_BOOT=2
                fi                   
             fi
       done
}	

######################################################################
##																	##
##             Logical Volume Management Functions			    	##
##																	##
######################################################################


# LVM Detection.
detect_lvm() {

  LVM_PV=$(pvs -o pv_name --noheading 2>/dev/null)
  LVM_VG=$(vgs -o vg_name --noheading 2>/dev/null)
  LVM_LV=$(lvs -o vg_name,lv_name --noheading --separator - 2>/dev/null)
  
  if [[ $LVM_LV = "" ]] && [[ $LVM_VG = "" ]] && [[ $LVM_PV = "" ]]; then
     LVM=0
  else
     LVM=1
  fi
 
}

# Where existing LVM is found, offer to deactivate it. Code adapted from the Manjaro installer.
# NEED TO ADD COMMAND TO REMOVE LVM2 FSTYPE.
deactivate_lvm() {

 LVM_DISABLE=0

    if [[ $LVM -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmDetTitle" --yesno "$_LvmDetBody1" 0 0 \
       && LVM_DISABLE=1 || LVM_DISABLE=0
    fi
    
    if [[ $LVM_DISABLE -eq 1 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmRmTitle" --infobox "$_LvmRmBody" 0 0
       sleep 2
       
        for i in ${LVM_LV}; do
            lvremove -f /dev/mapper/${i} >/dev/null 2>&1
        done

        for i in ${LVM_VG}; do
            vgremove -f ${i} >/dev/null 2>&1
        done

        for i in ${LV_PV}; do
            pvremove -f ${i} >/dev/null 2>&1
        done
        
        # This step will remove old lvm metadata on partitions where identified.
        LVM_PT=$(lvmdiskscan | grep 'LVM physical volume' | grep 'sd[a-z]' | sed 's/\/dev\///' | awk '{print $1}')
        for i in ${LVM_PT}; do
            dd if=/dev/zero bs=512 count=512 of=/dev/${i} >/dev/null 2>&1
        done
    fi

}

# Find and create a list of partitions that can be used for LVM. Partitions already used are excluded.
find_lvm_partitions() {

    LVM_PARTITIONS=""
    NUMBER_LVM_PARTITIONS=0
    lvm_partition_list=$(lvmdiskscan | grep -v 'LVM physical volume' | grep 'sd[a-z][1-99]' | sed 's/\/dev\///' | awk '{print $1}')
	
    for i in ${lvm_partition_list[@]}; do
        LVM_PARTITIONS="${LVM_PARTITIONS} ${i} -"
        NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS + 1 ))
    done
    
}

# This simplifies the creation of the PV and VG into a single step.
create_lvm() {

# subroutine to save a lot of repetition.
check_lv_size() {

  LV_SIZE_INVALID=0
  LV_SIZE_TYPE=$(echo ${LVM_LV_SIZE:$(( ${#LVM_LV_SIZE} - 1 )):1})
  chars=0
  
  # Check to see if anything was actually entered
  [[ ${#LVM_LV_SIZE} -eq 0 ]] && LV_SIZE_INVALID=1

  # Check if there are any non-numeric characters prior to the last one
  while [[ $chars -lt $(( ${#LVM_LV_SIZE} - 1 )) ]]; do
        if [[ ${LVM_LV_SIZE:chars:1} != [0-9] ]]; then
           LV_SIZE_INVALID=1
           break;
        fi
        chars=$(( chars + 1 ))
  done

  # Check to see if first character is '0'
  [[ ${LVM_LV_SIZE:0:1} -eq "0" ]] && LV_SIZE_INVALID=1

  # Check to see if last character is "G" or "M", and if so, whether the value is greater than
  # or equal to the LV remaining Size. If not, convert into MB for VG space remaining.      
  if [[ ${LV_SIZE_INVALID} -eq 0 ]]; then
      case ${LV_SIZE_TYPE} in
         "G") if [[ $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(( $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) * 1000 )) ))
              fi
              ;;
         "M") if [[ $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) -ge ${LVM_VG_MB} ]]; then
                 LV_SIZE_INVALID=1
              else
                 LVM_VG_MB=$(( LVM_VG_MB - $(echo ${LVM_LV_SIZE:0:$(( ${#LVM_LV_SIZE} - 1 ))}) ))
              fi
              ;;
           *) LV_SIZE_INVALID=1
              ;;
      esac
  fi
      
}

	# Check that there is at least one partition available for LVM
    if [[ $NUMBER_LVM_PARTITIONS -lt 1 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPartErrTitle" --msgbox "$_LvmPartErrBody" 0 0
        prep_menu
    fi
    
    # Create a temporary file to store the partition(s) selected. This is later used for the vgcreate command. 'x' is used as a marker.
    echo "x" > /tmp/.vgcreate
    
    # Name the Volume Group
    LVM_VG=""
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
    LVM_VG=$(cat ${ANSWER})

    # Loop while the Volume Group name starts with a "/", is blank, has spaces, or is already being used
    while [[ ${LVM_VG:0:1} == "/" ]] || [[ ${#LVM_VG} -eq 0 ]] || [[ $LVM_VG =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_VG}) != "" ]]; do
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgErrTitle" --msgbox "$_LvmNameVgErr" 0 0
              
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmNameVgTitle" --inputbox "$_LvmNameVgBody" 0 0 "" 2>${ANSWER} || prep_menu
        LVM_VG=$(cat ${ANSWER})
    done
    
    # Select the first or only partition for the Volume Group
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
    LVM_PARTITION=$(cat ${ANSWER})
    
    # add the partition to the temporary file for the vgcreate command
    # Remove selected partition from the list and deduct number of LVM viable partitions remaining
    sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
    LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
    sleep 1

    # Where there are viable partitions still remaining, run loop
    while [[ $NUMBER_LVM_PARTITIONS -gt 0 ]]; do

           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvSelTitle" --menu "$_LvmPvSelBody" 0 0 4 $"Done" $"-" ${LVM_PARTITIONS} 2>${ANSWER} || prep_menu 
           LVM_PARTITION=$(cat ${ANSWER})

           if [[ $LVM_PARTITION == "Done" ]]; then
              break;
           else
              sed -i "s/x/\/dev\/${LVM_PARTITION} x/" /tmp/.vgcreate
              LVM_PARTITIONS="$(echo $LVM_PARTITIONS | sed s/${LVM_PARTITION}$' -'//)"
              NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvCreateTitle" --infobox "\n$_Done\n\n" 0 0
              sleep 1
           fi

    done

    # Once all the partitions have been selected, remove 'x' from the .vgcreate file, then use it in 'vgcreate' command.
    # Also determine the size of the VG, to use for creating LVs for it.
    VG_PARTS=$(cat /tmp/.vgcreate | sed 's/x//')
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvConfTitle" --yesno "$_LvmPvConfBody1${LVM_VG} $_LvmPvConfBody2${VG_PARTS}" 0 0
    
    if [[ $? -eq 0 ]]; then
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvActTitle" --infobox "$_LvmPvActBody1${LVM_VG}.$_LvmPvActBody2" 0 0
       sleep 2
       vgcreate -f ${LVM_VG} ${VG_PARTS} >/dev/null 2>/tmp/.errlog
       check_for_error
       VG_SIZE=$(vgdisplay | grep 'VG Size' | awk '{print $3}' | sed 's/\..*//')
       VG_SIZE_TYPE=$(vgdisplay | grep 'VG Size' | awk '{print $4}' | sed 's/\..*//')
       dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmPvDoneTitle" --msgbox "$_LvmPvDoneBody1 '${LVM_VG}' $_LvmPvDoneBody2 (${VG_SIZE} ${VG_SIZE_TYPE}).\n\n" 0 0
       sleep 2
    else
       prep_menu
    fi

    # Convert the VG size into GB and MB. These variables are used to keep tabs on space available and remaining
    [[ ${VG_SIZE_TYPE:0:1} == "G" ]] && LVM_VG_MB=$(( VG_SIZE * 1000 )) || LVM_VG_MB=$VG_SIZE
    
    # Specify number of Logical volumes to create.
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
    NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    
    # Loop if the number of LVs is no 1-9 (including non-valid characters)
    while [[ $NUMBER_LOGICAL_VOLUMES != [1-9] ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumErrTitle" --msgbox "$_LvmLvNumErrBody" 0 0
 
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNumTitle" --inputbox "$_LvmLvNumBody1 ${LVM_VG}.$_LvmLvNumBody2" 0 0 "" 2>${ANSWER} || prep_menu
          NUMBER_LOGICAL_VOLUMES=$(cat ${ANSWER})
    done

    # Loop while the number of LVs is greater than 1. This is because the size of the last LV is automatic.
    while [[ $NUMBER_LOGICAL_VOLUMES -gt 1 ]]; do
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
          LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1" 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
          LVM_LV_SIZE=$(cat ${ANSWER})          
          check_lv_size 
          
          # Loop while an invalid value is entered.
          while [[ $LV_SIZE_INVALID -eq 1 ]]; do
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeErrTitle" --msgbox "$_LvmLvSizeErrBody" 0 0
          
                dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvSizeTitle" --inputbox "\n${LVM_VG}: ${VG_SIZE}${VG_SIZE_TYPE} (${LVM_VG_MB}MB $_LvmLvSizeBody1).$_LvmLvSizeBody2" 0 0 "" 2>${ANSWER} || prep_menu
                LVM_LV_SIZE=$(cat ${ANSWER})          
                check_lv_size
          done
          
          # Create the LV
          lvcreate -L ${LVM_LV_SIZE} ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
          check_for_error
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvDoneTitle" --msgbox "\n$_Done\n\nLV ${LVM_LV_NAME} (${LVM_LV_SIZE}) $_LvmPvDoneBody2.\n\n" 0 0
          NUMBER_LOGICAL_VOLUMES=$(( NUMBER_LOGICAL_VOLUMES - 1 ))
    done
    
    # Now the final LV. Size is automatic.      
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
    LVM_LV_NAME=$(cat ${ANSWER})

          # Loop if preceeded with a "/", if nothing is entered, if there is a space, or if that name already exists.
          while [[ ${LVM_LV_NAME:0:1} == "/" ]] || [[ ${#LVM_LV_NAME} -eq 0 ]] || [[ ${LVM_LV_NAME} =~ \ |\' ]] || [[ $(lsblk | grep ${LVM_LV_NAME}) != "" ]]; do
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameErrTitle" --msgbox "$_LvmLvNameErrBody" 0 0

              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmLvNameTitle" --inputbox "$_LvmLvNameBody1 $_LvmLvNameBody2 (${LVM_VG_MB}MB)." 0 0 "lvol" 2>${ANSWER} || prep_menu
              LVM_LV_NAME=$(cat ${ANSWER})
          done

    # Create the final LV
    lvcreate -l +100%FREE ${LVM_VG} -n ${LVM_LV_NAME} 2>/tmp/.errlog
    check_for_error
    NUMBER_LVM_PARTITIONS=$(( NUMBER_LVM_PARTITIONS - 1 ))
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_LvmCompTitle" --yesno "$_LvmCompBody" 0 0 \
    && show_devices || prep_menu
}

######################################################################
##																	##
##                    Installation Functions						##
##																	##
######################################################################	

multilib_question()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_multilib_title" --yesno "$_yesno_multilib_body" 0 0

	if [[ $? -eq 0 ]]; then
		echo "[multilib]" >> /etc/pacman.conf
		echo "Include = /etc/pacman.d/mirrorlist" >> /etc/pacman.conf
		_multilib=1
	else
		_multilib=0
	fi
}

mirrorlist_question()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MirrorlistTitle" --yesno "$_yesno_mirrorlist_body" 0 0

	if [[ $? -eq 0 ]]; then
		sudo cp -f /etc/pacman.d/mirrorlist ${MOUNTPOINT}/etc/pacman.d/mirrorlist
	fi
}

function check_s_lst_pkg {
	local temp_pkg
	temp_pkg=("$@")
	declare -a new_pkg
	temp=""
	for i in ${temp_pkg[*]}; do
		pacman -Ss $i 1>/dev/null 2>/dev/null
		err=$?
		if [[ $err -eq 0 ]]; then 
			new_pkg=("${new_pkg[*]}" "$i")
		fi
	done
	echo ${new_pkg[*]}
}
function check_q_lst_pkg {
	local temp_pkg
	temp_pkg=("$@")
	declare -a new_pkg
	temp=""
	for i in ${temp_pkg[*]}; do
		pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -Qs $i 1>/dev/null 2>/dev/null
		err=$?
		[[ $err != "0" ]] && new_pkg=("${new_pkg[@]}" "$i")
	done
	echo ${new_pkg[*]}
}

info_search_pkg()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_nfo_search_pkg_title" --infobox "$_nfo_search_pkg_body" 0 0
}

install_wireless_programm()
{
	if [[ $_net_cntrl == "0" ]]; then
		dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_iwp_title" --yesno "$_yesno_iwp_body" 0 0
		if [[ $? -eq 0 ]]; then
			_net_cntrl=1
			clear
			info_search_pkg
			_list_wifi_pkg=$(check_s_lst_pkg "${_wifi_pkg[*]}")
			wait
			clear
			[[ ${_list_wifi_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_wifi_pkg[*]} 2>/tmp/.errlog
		fi
	fi
}

search_translit_pkg()
{
	stp=$(pacman -Ss | grep -Ei "core|extra|community|multilib" | sed 's/extra\///' | sed 's/core\///' | sed 's/community\///' | sed 's/multilib\///' | grep -E "^$1" | awk '{print $1}' | grep -E "$2$")
	echo "${stp[*]}"
}

install_gengen()
{
	_gengen_menu=""
	if [[ $_gengen_once == "0" ]]; then
		_gengen_once=1
		clear
		info_search_pkg
		_list_general_pkg=$(check_s_lst_pkg "${_general_pkg[*]}")
		wait
		_gengen_menu=""
		for i in ${_list_general_pkg[*]}; do
			_gengen_menu="${_gengen_menu} ${i} - on"
		done
		wait
		clear
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_gengen" --checklist "$_ch_mn_bd" 0 0 16 ${_gengen_menu} 2>${ANSWER}
	_ch_gengen=$(cat ${ANSWER})
	clear
	[[ ${_ch_gengen[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_ch_gengen[*]} 2>/tmp/.errlog
}
install_archivers()
{
	if [[ $_archivers_once == "0" ]]; then
		_archivers_once=1
		clear
		info_search_pkg
		_list_archivers_pkg=$(check_s_lst_pkg "${_archivers_pkg[*]}")
		wait
		_clist_archivers_pkg=$(check_q_lst_pkg "${_list_archivers_pkg[*]}")
		wait
		for i in ${_clist_archivers_pkg[*]}; do
			archivers_menu="${archivers_menu} ${i} - on"
		done
		wait
		clear
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_archivers" --checklist "$_ch_mn_bd" 0 0 16 ${archivers_menu} 2>${ANSWER}
	_ch_archivers=$(cat ${ANSWER})
	clear
	[[ ${_ch_archivers[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_ch_archivers[*]} 2>/tmp/.errlog
}
install_ttftheme()
{
	if [[ $_ttf_once == "0" ]]; then
		_ttf_once=1
		clear
		info_search_pkg
		_list_ttf_theme_pkg=$(check_s_lst_pkg "${_ttf_theme_pkg[*]}")
		wait
		_clist_ttf_theme_pkg=$(check_q_lst_pkg "${_list_ttf_theme_pkg[*]}")
		wait
		for i in ${_clist_ttf_theme_pkg[*]}; do
			_ttf_menu="${_ttf_menu} ${i} - on"
		done
		wait
		clear
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_ttf_theme" --checklist "$_ch_mn_bd" 0 0 16 ${_ttf_menu} 2>${ANSWER}
	_ch_ttf=$(cat ${ANSWER})
	clear
	[[ ${_ch_ttf[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_ch_ttf[*]} 2>/tmp/.errlog
}
install_standartpkg()
{
	if [[ $_stpkg_once == "0" ]]; then
		_stpkg_once=1
		clear
		info_search_pkg
		_list_gr_editor=$(check_s_lst_pkg "${_gr_editor[*]}")
		wait
		[[ ${_list_gr_editor[*]} != "" ]] && _tr_gr_editor=$(search_translit_pkg "${_gr_editor[*]}" "$_user_local")
		wait
		[[ ${_tr_gr_editor[*]} != "" ]]	&& _list_gr_editor="${_list_gr_editor} ${_tr_gr_editor[*]}"
		_list_office=$(check_s_lst_pkg "${_office}")
		wait
		[[ ${_list_office[*]} != "" ]] && _tr_office=$(search_translit_pkg "${_office}" "$_user_local")
		wait
		[[ ${_tr_office[*]} != "" ]] && _list_office="${_list_office} ${_tr_office[*]}"
		_list_minimal_pkg=$(check_s_lst_pkg "${_minimal_pkg[*]}")
		wait
		[[ ${_list_gr_editor[*]} != "" ]] && _list_minimal_pkg="${_list_minimal_pkg} ${_list_gr_editor[*]}"
		[[ ${_list_office[*]} != "" ]] && _list_minimal_pkg="${_list_minimal_pkg} ${_list_office[*]}"
		wait
		_clist_minimal_pkg=$(check_q_lst_pkg "${_list_minimal_pkg[*]}")
		wait
		for i in ${_clist_minimal_pkg[*]}; do
			_standart_pkg_menu="${_standart_pkg_menu} ${i} - on"
		done
		wait
		clear
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_add_pkg" --checklist "$_ch_mn_bd" 0 0 16 ${_standart_pkg_menu} 2>${ANSWER}
	_ch_standart_pkg=$(cat ${ANSWER})
	clear
	[[ ${_ch_standart_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_ch_standart_pkg[*]} 2>/tmp/.errlog
}
install_otherpkg()
{
	if [[ $_other_pkg_once == "0" ]]; then
		_other_pkg_once=1
		clear
		info_search_pkg
		_list_other_pkg=$(check_s_lst_pkg "${_other_pkg[*]}")
		wait
		_clist_other_pkg=$(check_q_lst_pkg "${_list_other_pkg[*]}")
		wait
		for i in ${_clist_other_pkg[*]}; do
			_other_pkg_menu="${_other_pkg_menu} ${i} - on"
		done
		clear
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_extra_pkg" --checklist "$_ch_mn_bd" 0 0 16 ${_other_pkg_menu} 2>${ANSWER}
	_ch_other_pkg=$(cat ${ANSWER})
	clear
	[[ ${_ch_other_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_ch_other_pkg[*]} 2>/tmp/.errlog
}
install_pm_menu()
{
	install_pamac_aur()
	{
		cp ${_pamac_aur} /var/lib/pacman/local/
		cp ${_pamac_aur} ${MOUNTPOINT}/var/lib/pacman/local/
		pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/pamac-aur-7.3.3-1-x86_64.pkg.tar.xz --noconfirm
	}
	install_pamac_classic()
	{
		cp ${_pamac_classic} ${MOUNTPOINT}/var/lib/pacman/local/
		cp ${_pamac_classic} /var/lib/pacman/local/
		pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/pamac-classic-7.0.0-1-x86_64.pkg.tar.xz --noconfirm
	}
	install_pyt()
	{
		cp ${_package_query} ${MOUNTPOINT}/var/lib/pacman/local/
		cp ${_yaourt} ${MOUNTPOINT}/var/lib/pacman/local/
		cp ${_package_query} /var/lib/pacman/local/
		cp ${_yaourt} /var/lib/pacman/local/
		pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/package-query-1.9-3-x86_64.pkg.tar.xz --noconfirm
		pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/yaourt-1.9-1-any.pkg.tar.xz --noconfirm
	}
	install_timeshift()
	{
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_timeshift_title" --yesno "$_yesno_timeshift_body" 0 0
		
		if [[ $? -eq 0 ]]; then
			cp ${_timeshift} ${MOUNTPOINT}/var/lib/pacman/local/
			cp ${_timeshift} /var/lib/pacman/local/
			clear
			pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/timeshift-19.01-2-x86_64.pkg.tar.xz --noconfirm
		fi
	}
	install_github_desktop()
	{
		dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_github_desktop_title" --yesno "$_yesno_github_desktop_body" 0 0

		if [[ $? -eq 0 ]]; then
			cp ${_github_desktop} ${MOUNTPOINT}/var/lib/pacman/local/
			cp ${_github_desktop} /var/lib/pacman/local/
			clear
			pacman --root ${MOUNTPOINT} --dbpath ${MOUNTPOINT}/var/lib/pacman -U /var/lib/pacman/local/github-desktop-2.1.0-2-x86_64.pkg.tar.xz --noconfirm
		fi
	}
	clear
	dialog --default-item 2 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_pkg_meneger" --menu "$_pm_menu_body" 0 0 2 \
 	"1" $"pamac-aur" \
	"2" $"pamac-classic" 2>${ANSWER}
	case $(cat ${ANSWER}) in
    "1") install_pyt
		install_pamac_aur
		install_timeshift
		install_github_desktop
         ;;
    "2") install_pyt
		install_pamac_classic
		install_timeshift
		install_github_desktop
         ;;  
    esac
}

install_base() {
    ipv6_disable()
	{
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_ipv6_title" --yesno "$_yesno_ipv6_body" 0 0
		 if [[ $? -eq 0 ]]; then
			[ -e ${MOUNTPOINT}/etc/sysctl.d/ ] || mkdir ${MOUNTPOINT}/etc/sysctl.d/
			echo "# if problem to download packets then create file:" > ${MOUNTPOINT}/etc/sysctl.d/40-ipv6.conf
			echo "# /etc/sysctl.d/40-ipv6.conf" >> ${MOUNTPOINT}/etc/sysctl.d/40-ipv6.conf
			echo "" >> ${MOUNTPOINT}/etc/sysctl.d/40-ipv6.conf
			echo "net.ipv6.conf.all.disable_ipv6=1" >> ${MOUNTPOINT}/etc/sysctl.d/40-ipv6.conf
		fi	
	}
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBseTitle" \
    --menu "$_InstBseBody" 0 0 4 \
 	"1" "$_InstBaseLK" \
	"2" "$_InstBaseLKBD" \
	"3" "$_InstBaseLTS" \
	"4" "$_InstBaseLTSBD" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") # Latest Kernel
             clear
			info_search_pkg
			_list_base_pkg=$(check_s_lst_pkg "${_base_pkg[*]}")
			wait
			clear
			[[ ${_list_base_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} base ${_list_base_pkg[*]} 2>/tmp/.errlog \
			|| pacstrap ${MOUNTPOINT} base 2>/tmp/.errlog
			 ipv6_disable
             ;;
        "2") # Latest Kernel and base-devel
             clear
			 info_search_pkg
			# _list_base_pkg=$(check_s_lst_pkg "${_base_pkg[*]}")
			_list_base_devel=$(check_s_lst_pkg "${_base_devel_pkg[*]}")
			wait
			clear
			[[ ${_list_base_devel[*]} != "" ]] && pacstrap ${MOUNTPOINT} base base-devel ${_list_base_devel[*]} 2>/tmp/.errlog \
			|| pacstrap ${MOUNTPOINT} base base-devel 2>/tmp/.errlog
			 ipv6_disable
             ;;
        "3") # LTS Kernel
             clear
			 info_search_pkg
			 _list_lts_pkg=$(check_s_lst_pkg "${_lts_pkg[*]}")
			 wait
			 _list_base_pkg=$(check_s_lst_pkg "${_base_pkg[*]}")
			 wait
			 clear
			 [[ ${_list_lts_pkg[*]} != "" ]] && LTS=1
			 [[ ${_list_lts_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} base ${_list_lts_pkg[*]} 2>/tmp/.errlog \
			 || pacstrap ${MOUNTPOINT} base 2>/tmp/.errlog
			 [[ ${_list_base_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_base_pkg[*]} 2>/tmp/.errlog
			 #pacstrap ${MOUNTPOINT} base ${_list_lts_pkg[*]} 2>/tmp/.errlog
             # [[ $? -eq 0 ]] && LTS=1
			 ipv6_disable
             ;;
        "4") # LTS Kernel and base-devel
             clear
			 info_search_pkg
			 _list_lts_pkg=$(check_s_lst_pkg "${_lts_pkg[*]}")
			 wait
			  _list_base_devel=$(check_s_lst_pkg "${_base_devel_pkg[*]}")
			 wait
			 clear
			 [[ ${_list_lts_pkg[*]} != "" ]] && LTS=1
			  [[ ${_list_lts_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} base base-devel ${_list_lts_pkg[*]} 2>/tmp/.errlog \
			  || pacstrap ${MOUNTPOINT} base base-devel 2>/tmp/.errlog
			  [[ ${_list_base_devel[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_base_devel[*]} 2>/tmp/.errlog
			 #pacstrap ${MOUNTPOINT} base base-devel ${_list_lts_pkg[*]} 2>/tmp/.errlog
             #[[ $? -eq 0 ]] && LTS=1
			 ipv6_disable
             ;;
          *) install_base_menu
             ;;
    esac  	
     
	if [[ $_multilib == "1" ]]; then
		echo "[multilib]" >>  ${MOUNTPOINT}/etc/pacman.conf
		echo "Include = /etc/pacman.d/mirrorlist" >>  ${MOUNTPOINT}/etc/pacman.conf
	fi
	
	mirrorlist_question	
	 
    # If the virtual console has been set, then copy config file to installation
   # [[ -e /tmp/vconsole.conf ]] && cp /tmp/vconsole.conf ${MOUNTPOINT}/etc/vconsole.conf 2>>/tmp/.errlog
    check_for_error

  #check for a wireless device
  if [[ $(lspci | grep -i "Network Controller") != "" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstWirTitle" --infobox "$_InstWirBody" 0 0 
     sleep 2
	 clear
	 install_wireless_programm
     clear
     check_for_error
  fi

}

# Adapted from AIS. Integrated the configuration elements.
install_bootloader() {

bios_bootloader() {	
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBiosBtTitle" \
    --menu "$_InstBiosBtBody" 0 0 3 \
 	"1" $"Grub2" \
	"2" $"Syslinux [MBR]" \
	"3" $"Syslinux [/]" 2>${ANSWER}
	
	clear
	
	case $(cat ${ANSWER}) in
		"1") # Grub
			clear
			info_search_pkg
			_list_grub_pkg=$(check_s_lst_pkg "${_grub_pkg[*]}")
			wait
			clear
			[[ ${_list_grub_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_grub_pkg[*]} 2>/tmp/.errlog
			check_for_error
             
			 # An LVM VG/LV can consist of multiple devices. Where LVM used, user must select the device manually.
			 if [[ $LVM_ROOT -eq 1 ]]; then
				select_grub_device
			 else
				dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstGrubDevTitle" --yesno "$_InstGrubDevBody ($INST_DEV)?$_InstGrubDevBody2" 0 0
                
				if [[ $? -eq 0 ]]; then
					clear
					dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
					sleep 1 
					arch_chroot "grub-install --target=i386-pc --recheck ${INST_DEV}" 2>/tmp/.errlog
					check_for_error
				else   
					select_grub_device
				fi
			 fi
                       
			 arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>/tmp/.errlog
			 check_for_error
             
			 # if /boot is LVM then amend /boot/grub/grub.cfg accordingly
			 if ( [[ $LVM_ROOT -eq 1 ]] && [[ $LVM_SEP_BOOT -eq 0 ]] ) || [[ $LVM_SEP_BOOT -eq 2 ]]; then
				sed -i '/### BEGIN \/etc\/grub.d\/00_header ###/a insmod lvm' ${MOUNTPOINT}/boot/grub/grub.cfg
			 fi
         
			 BOOTLOADER="Grub"
             ;;          
	"2"|"3") # Syslinux
			clear
			info_search_pkg
			_list_syslinux_pkg=$(check_s_lst_pkg "${_syslinux_pkg[*]}")
			wait
			clear
			[[ ${_list_syslinux_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_syslinux_pkg[*]} 2>/tmp/.errlog
          
			 # Install to MBR or root partition, accordingly
			 [[ $(cat ${ANSWER}) == "2" ]] && arch_chroot "syslinux-install_update -iam" 2>>/tmp/.errlog
			 [[ $(cat ${ANSWER}) == "3" ]] && arch_chroot "syslinux-install_update -i" 2>>/tmp/.errlog
			 check_for_error
             
			 # Amend configuration file depending on whether lvm used or not for root.
			 if [[ $LVM_ROOT -eq 0 ]]; then
				sed -i "s/sda[0-9]/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
			 else
				sed -i "s/APPEND.*/APPEND root=\/dev\/mapper\/${ROOT_PART} rw/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
			 fi
             
			 # Amend configuration file for LTS kernel and/or btrfs subvolume as root
			 [[ $LTS -eq 1 ]] && sed -i 's/linux/linux-lts/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
			 [[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             
			 BOOTLOADER="Syslinux"
			 ;;
		  *) install_base_menu
		     ;;
   esac
}

uefi_bootloader() {

    #Ensure again that efivarfs is mounted
	[[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars
     
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstUefiBtTitle" \
    --menu "$_InstUefiBtBody" 0 0 3 \
    "1" $"Grub2" \
    "2" $"rEFInd" \
    "3" $"systemd-boot" 2>${ANSWER}

     case $(cat ${ANSWER}) in
     "1") # Grub2
          clear
		  info_search_pkg
		  _list_grub_uefi_pkg=$(check_s_lst_pkg "${_grub_uefi_pkg[*]}")
		 wait
		 clear
		 [[ ${_list_grub_uefi_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_grub_uefi_pkg[*]} 2>/tmp/.errlog
         check_for_error
          
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Grub-install " --infobox "$_PlsWaitBody" 0 0
          sleep 1
          arch_chroot "grub-install --target=x86_64-efi --efi-directory=${UEFI_MOUNT} --bootloader-id=arch_grub --recheck" 2>/tmp/.errlog
          arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
          check_for_error

          # Ask if user wishes to set Grub as the default bootloader and act accordingly
          dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetGrubDefTitle" --yesno "$_SetGrubDefBody ${UEFI_MOUNT}/EFI/boot $_SetGrubDefBody2" 0 0
          
          if [[ $? -eq 0 ]]; then
             arch_chroot "mkdir ${UEFI_MOUNT}/EFI/boot" 2>/tmp/.errlog
             arch_chroot "cp -r ${UEFI_MOUNT}/EFI/arch_grub/grubx64.efi ${UEFI_MOUNT}/EFI/boot/bootx64.efi" 2>>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetDefDoneTitle" --infobox "\nGrub $_SetDefDoneBody" 0 0
             sleep 2
          fi
          
          BOOTLOADER="Grub"
          ;;
 
      "2") # rEFInd
           # Ensure that UEFI partition has been mounted to /boot/efi due to bug in script. Could "fix" it for installation, but
           # This could result in unknown consequences should the script be updated at some point.
           if [[ $UEFI_MOUNT == "/boot/efi" ]]; then      
              clear
			  info_search_pkg
			  _list_reefind_pkg=$(check_s_lst_pkg "${_reefind_pkg[*]}")
			  wait
			  clear
			  [[ ${_list_reefind_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_reefind_pkg[*]} 2>/tmp/.errlog
              check_for_error   
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SetRefiDefTitle" --yesno "$_SetRefiDefBody ${UEFI_MOUNT}/EFI/boot $_SetRefiDefBody2" 0 0
              
              if [[ $? -eq 0 ]]; then
                 clear
                 arch_chroot "refind-install --usedefault ${UEFI_PART} --alldrivers" 2>/tmp/.errlog
              else   
                 clear
                 arch_chroot "refind-install" 2>/tmp/.errlog
              fi   
              
              check_for_error
              
              # Now generate config file to pass kernel parameters. Default read only (ro) changed to read-write (rw),
              # and amend where using btfs subvol root       
              arch_chroot "refind-mkrlconf" 2>/tmp/.errlog
              check_for_error
              sed -i 's/ro /rw /g' ${MOUNTPOINT}/boot/refind_linux.conf
              [[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/refind_linux.conf
              
              BOOTLOADER="rEFInd"
           else 
              dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_RefiErrTitle" --msgbox "$_RefiErrBody" 0 0
              uefi_bootloader
           fi
           ;;
         
     "3") # systemd-boot
          clear
		  info_search_pkg
		  _list_systemd_boot_pkg=$(check_s_lst_pkg "${_systemd_boot_pkg[*]}")
		  wait
		  clear
		  [[ ${_list_systemd_boot_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_systemd_boot_pkg[*]} 2>/tmp/.errlog
          arch_chroot "bootctl --path=${UEFI_MOUNT} install" 2>>/tmp/.errlog
          check_for_error
          
          # Deal with LVM Root
          if [[ $LVM_ROOT -eq 0 ]]; then
             sysdb_root=$(blkid -s PARTUUID $"/dev/"${ROOT_PART} | sed 's/.*=//g' | sed 's/"//g')
          else
             sysdb_root="/dev/mapper/${ROOT_PART}" 
          fi
           
          # Deal with LTS Kernel
          if [[ $LTS -eq 1 ]]; then
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux-lts\ninitrd\t/initramfs-linux-lts.img\noptions\troot=PARTUUID=${sysdb_root} rw" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
          else
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=PARTUUID=${sysdb_root} rw" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
          fi
          
          # Fix LVM Root installations, and deal with btrfs root subvolume mounting
          [[ $LVM_ROOT -eq 1 ]] && sed -i "s/PARTUUID=//g" ${MOUNTPOINT}/boot/loader/entries/arch.conf
          [[ $BTRFS_MNT != "" ]] && sed -i "s/rw/rw $BTRFS_MNT/g" ${MOUNTPOINT}/boot/loader/entries/arch.conf
          
          BOOTLOADER="systemd-boot"
          # Set the loader file  
          echo -e "default  arch\ntimeout  5" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf 2>/tmp/.errlog
          check_for_error
          ;;
          
      *) install_base_menu
         ;;
      esac 

}

    check_mount
    # Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
    check_for_error

    if [[ $SYSTEM == "BIOS" ]]; then
       bios_bootloader
    else
       uefi_bootloader
    fi
}

# Needed for broadcom and other network controllers
install_wireless_firmware() {
    
	if [[ $_wifi_menu_form == 0 ]]; then
		_wifi_menu_form=1
		clear
		info_search_pkg
		_list_broadcom=$(check_s_lst_pkg "${_broadcom[*]}")
		wait
		_list_intel_2100=$(check_s_lst_pkg "${_intel_2100[*]}")
		wait
		_list_intel_2200=$(check_s_lst_pkg "${_intel_2200[*]}")
		wait
		[[ ${_list_broadcom[*]} != "" ]] && _list_wifi_adapter_pkg="${_list_wifi_adapter_pkg} ${_list_broadcom[*]}"
		[[ ${_list_intel_2100[*]} != "" ]] && _list_wifi_adapter_pkg="${_list_wifi_adapter_pkg} ${_list_intel_2100[*]}"
		[[ ${_list_intel_2200[*]} != "" ]] && _list_wifi_adapter_pkg="${_list_wifi_adapter_pkg} ${_list_intel_2200[*]}"
		_wifi_menu="Show_Devices -"
		for i in ${_list_wifi_adapter_pkg[*]}; do
			if [[ ! $i =~ .(2100) ]] && [[ ! $i =~ .(2200) ]]; then
				_wifi_menu="${_wifi_menu} Broadcom_802.11b/g/n -"
			elif [[ $i =~ .(2100) ]]; then
				_wifi_menu="${_wifi_menu} Intel_PRO/Wireless_2100 -"
			elif [[ $i =~ .(2200) ]]; then
				_wifi_menu="${_wifi_menu} Intel_PRO/Wireless_2200 -"
			fi
		done
		_wifi_menu="${_wifi_menu} All -"
		_wifi_menu="${_wifi_menu} Back -"
		clear
	fi
	
    check_mount
	
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelssFirmTitle" --menu "$_WirelssFirmBody" 0 0 6 ${_wifi_menu} 2>${ANSWER}
	
    #dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelssFirmTitle" --menu "$_WirelssFirmBody" 0 0 6 \
 	#"1" "$_SeeWirelessDev" \
 	#"2" $"Broadcom 802.11b/g/n" \
 	#"3" $"Intel PRO/Wireless 2100" \
 	#"4" $"Intel PRO/Wireless 2200" \
 	#"5" "$_All" \
 	#"6" "$_Back" 2>${ANSWER}

    case $(cat ${ANSWER}) in
    "Show_Devices") # Identify the Wireless Device 
        lspci -k | grep -i -A 2 "network controller" > /tmp/.wireless
        if [[ $(cat /tmp/.wireless) != "" ]]; then
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --textbox /tmp/.wireless 0 0
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WirelessShowTitle" --msgbox "$_WirelessErrBody" 7 30
        fi
        ;;
    "Broadcom_802.11b/g/n") # Broadcom
         clear
         pacstrap ${MOUNTPOINT} ${_list_broadcom[*]} 2>/tmp/.errlog
		 install_wireless_programm
        ;;
    "Intel_PRO/Wireless_2100") # Intel 2100
         clear
         pacstrap ${MOUNTPOINT} ${_list_intel_2100[*]} 2>/tmp/.errlog
		 install_wireless_programm
        ;;
    "Intel_PRO/Wireless_2200") # Intel 2200
         clear
         pacstrap ${MOUNTPOINT} ${_list_intel_2200[*]} 2>/tmp/.errlog
		 install_wireless_programm
        ;;
    "All") # All
         clear
         pacstrap ${MOUNTPOINT} ${_list_wifi_adapter_pkg[*]} 2>/tmp/.errlog
		 install_wireless_programm
        ;;
      *) install_base_menu
        ;;
    esac
    
    check_for_error
    install_wireless_firmware

}

# Install alsa, xorg and input drivers. Also copy the xkbmap configuration file created earlier to the installed system
# This will run only once.
install_alsa_xorg_input() {

     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_AXITitle" --msgbox "$_AXIBody" 0 0
     clear
	 info_search_pkg
	 _list_x_pkg=$(check_s_lst_pkg "${_x_pkg[*]}")
	 wait
	 _clist_x_pkg=$(check_q_lst_pkg "${_list_x_pkg[*]}")
	 wait
	 clear
	 [[ ${_clist_x_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_clist_x_pkg[*]} 2>/tmp/.errlog
     check_for_error
     
     # copy the keyboard configuration file, if generated
     if [[ -e /tmp/00-keyboard.conf ]]; then
		#[[ -e ${MOUNTPOINT}/etc/X11/xorg.conf.d/ ]] || mkdir ${MOUNTPOINT}/etc/X11/xorg.conf.d
		cp -f /tmp/00-keyboard.conf ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf
		sed -i 's/^HOOKS=(base/HOOKS=(base consolefont keymap /' ${MOUNTPOINT}/etc/mkinitcpio.conf
	 fi
     # now copy across .xinitrc for all user accounts
     user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
	 for i in ${user_list[@]}; do
	     cp -f ${MOUNTPOINT}/etc/X11/xinit/xinitrc ${MOUNTPOINT}/home/$i
	     arch_chroot "chown -R ${i}:users /home/${i}"
     done
     
     AXI_INSTALLED=1

}

setup_graphics_card() {

# Save repetition
install_intel(){
	clear
	info_search_pkg
	_list_intel_pkg=$(check_s_lst_pkg "${_intel_pkg[*]}")
	wait
	clear
	[[ ${_list_intel_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_intel_pkg[*]} 2>/tmp/.errlog
    sed -i 's/MODULES=""/MODULES="i915"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
           
    # Intel microcode (Grub, Syslinux and systemd-boot). rEFInd is yet to be added.
    # Done as seperate if statements in case of multiple bootloaders.
    if [[ -e ${MOUNTPOINT}/boot/grub/grub.cfg ]]; then
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " grub-mkconfig " --infobox "$_PlsWaitBody" 0 0
		sleep 1
		arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg" 2>>/tmp/.errlog
	fi
			   
	if [[ -e ${MOUNTPOINT}/boot/syslinux/syslinux.cfg ]]; then
		sed -i 's/..\/initramfs-linux.img/..\/intel-ucode.img,..\/initramfs-linux.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-lts.img/..\/intel-ucode.img,..\/initramfs-linux-lts.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-fallback.img/..\/intel-ucode.img,..\/initramfs-linux-fallback.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
		sed -i 's/..\/initramfs-linux-lts-fallback.img/..\/intel-ucode.img,..\/initramfs-linux-lts-fallback.img/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
	fi
			   
	if [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf ]]; then
		sed -i '/linux \//a initrd \/intel-ucode.img' ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf                    
	fi
}

# Save repetition
install_ati(){
	clear
	info_search_pkg
	_list_ati_pkg=$(check_s_lst_pkg "${_ati_pkg[*]}")
	wait
	clear
	[[ ${_list_ati_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_ati_pkg[*]} 2>/tmp/.errlog
	sed -i 's/MODULES=""/MODULES="radeon"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
}

# Search Vedo Driver to nvidia-390xx in template 'nvidia-[0-9]{3}'
_nvidia_name=""
nvidia_search()
{
	nvsearch=$(pacman -Ss | grep -Ei "core|extra|community|multilib" | sed 's/extra\///' | sed 's/core\///' | sed 's/community\///' | sed 's/multilib\///' | grep -E "nvidia-[0-9]{3}xx" | awk '{print $1}' | awk '/^nvidia-[0-9]{3}xx$/')
	_nvidia_name=${nvsearch[*]}
}

# Main menu. Correct option for graphics card should be automatically highlighted.

	GRAPHIC_CARD=""
	INTEGRATED_GC="N/A"
	GRAPHIC_CARD=$(lspci | grep -Ei "3d|vga" | sed 's/.*://' | sed 's/(.*//' | sed 's/^[ \t]*//')
	
	# Highlight menu entry depending on GC detected. Extra work is needed for NVIDIA
	if 	[[ $(echo $GRAPHIC_CARD | grep -i "nvidia") != "" ]]; then
		# If NVIDIA, first need to know the integrated GC
		[[ $(lscpu | grep -i "intel\|lenovo") != "" ]] && INTEGRATED_GC="Intel" || INTEGRATED_GC="ATI"
				
		# Second, identity the NVIDIA card and driver / menu entry
		if [[ $(dmesg | grep -i 'chipset' | grep -i 'nvc\|nvd\|nve') != "" ]]; then HIGHLIGHT_SUB_GC=7
		elif [[ $(dmesg | grep -i 'chipset' | grep -i 'nva\|nv5\|nv8\|nv9'﻿) != "" ]]; then HIGHLIGHT_SUB_GC=9
		elif [[ $(dmesg | grep -i 'chipset' | grep -i 'nv4\|nv6') != "" ]]; then HIGHLIGHT_SUB_GC=10
		else HIGHLIGHT_SUB_GC=5
		fi
	
	# All non-NVIDIA cards / virtualisation
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'ati') != "" ||  $(echo $GRAPHIC_CARD | grep -i 'amd') != "" ]]; then HIGHLIGHT_SUB_GC=2
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'intel\|lenovo') != "" ]]; then HIGHLIGHT_SUB_GC=3
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'via') != "" ]]; then HIGHLIGHT_SUB_GC=11
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'virtualbox') != "" ]]; then HIGHLIGHT_SUB_GC=12
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'vmware') != "" ]]; then HIGHLIGHT_SUB_GC=13
	else HIGHLIGHT_SUB_GC=14
	fi
	
   dialog --default-item ${HIGHLIGHT_SUB_GC} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_GCtitle" \
    --menu "$GRAPHIC_CARD\n" 0 0 11 \
 	"1" "$_DevShowOpt" \
	"2" $"xf86-video-ati" \
	"3" $"xf86-video-intel" \
	"4" $"xf86-video-nouveau" \
	"5" $"xf86-video-nouveau (+ $INTEGRATED_GC)" \
	"6" $"Nvidia" \
	"7" $"Nvidia (+ $INTEGRATED_GC)" \
	"8" $"Nvidia-xxx(auto-search new-version)" \
	"9" $"Nvidia-xxx(auto-search new-version) (+ $INTEGRATED_GC)" \
	"10" $"xf86-video-openchrome" \
	"11" $"virtualbox-guest-xxx" \
    "12" $"xf86-video-vmware" \
	"13" "$_GCUnknOpt / xf86-video-fbdev" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") lspci -k | grep -Ei "3d|vga" > /tmp/.vga
			if [[ $(cat /tmp/.vga) != "" ]]; then
				dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevShowOpt" --textbox /tmp/.vga 0 0
			else
				dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DevShowOpt" --msgbox "$_WirelessErrBody" 7 30
			fi
			;;
		"2") # ATI/AMD
			install_ati
             ;;
        "3") # Intel
			install_intel
             ;;
		"4") # Nouveau
			clear
			info_search_pkg
			_list_nouveau=$(check_s_lst_pkg "${_nouveau[*]}")
			wait
			clear
			[[ ${_list_nouveau[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_nouveau[*]} 2>/tmp/.errlog
            sed -i 's/MODULES=""/MODULES="nouveau"/' ${MOUNTPOINT}/etc/mkinitcpio.conf       
             ;;
        "5") # Nouveau / NVIDIA
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel	
			clear
			info_search_pkg
			_list_nouveau=$(check_s_lst_pkg "${_nouveau[*]}")
			wait
			clear
			[[ ${_list_nouveau[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_nouveau[*]} 2>/tmp/.errlog
            sed -i 's/MODULES=""/MODULES="nouveau"/' ${MOUNTPOINT}/etc/mkinitcpio.conf       
             ;;
		"6") # NVIDIA
			arch_chroot "pacman -Rdds --noconfirm mesa"
			clear
			info_search_pkg
			[[ $LTS == 0 ]] && _list_nvidia_pkg=$(check_s_lst_pkg "${_nvidia_pkg[*]}") || _list_nvidia_lts_pkg=$(check_s_lst_pkg "${_nvidia_lts_pkg[*]}")
			wait
			clear
            # Now deal with kernel installed
            [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} ${_list_nvidia_pkg[*]} 2>/tmp/.errlog \
            || pacstrap ${MOUNTPOINT} ${_list_nvidia_lts_pkg[*]} 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;
        "7") # NVIDIA-GF
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa"
			clear
			info_search_pkg
			[[ $LTS == 0 ]] && _list_nvidia_pkg=$(check_s_lst_pkg "${_nvidia_pkg[*]}") || _list_nvidia_lts_pkg=$(check_s_lst_pkg "${_nvidia_lts_pkg[*]}")
			wait
			clear
            # Now deal with kernel installed
            [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} ${_list_nvidia_pkg[*]} 2>/tmp/.errlog \
            || pacstrap ${MOUNTPOINT} ${_list_nvidia_lts_pkg[*]} 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;
		"8") # NVIDIA-xxx
			arch_chroot "pacman -Rdds --noconfirm mesa"
            # Now deal with kernel installed
			clear
			info_search_pkg
			nvidia_search
			wait
			_nvidia_xxx=($_nvidia_name $_nvidia_name-utils $_nvidia_name-settings)
			_nvidia_lts_xxx=($_nvidia_name-lts $_nvidia_name-utils $_nvidia_name-settings)
			[[ $LTS == 0 ]] && _list_nvidia_xxx=$(check_s_lst_pkg "${_nvidia_xxx[*]}") || _list_nvidia_lts_xxx=$(check_s_lst_pkg "${_nvidia_lts_xxx[*]}")
			wait
			clear
            [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} ${_list_nvidia_xxx[*]} 2>/tmp/.errlog \
            || pacstrap ${MOUNTPOINT} ${_list_nvidia_lts_xxx[*]} 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;          
        "9") # NVIDIA-xxx
			[[ $INTEGRATED_GC == "ATI" ]] &&  install_ati || install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa"
			clear
            # Now deal with kernel installed
			info_search_pkg
			nvidia_search
			wait
			_nvidia_xxx=($_nvidia_name $_nvidia_name-utils $_nvidia_name-settings)
			_nvidia_lts_xxx=($_nvidia_name-lts $_nvidia_name-utils $_nvidia_name-settings)
			[[ $LTS == 0 ]] && _list_nvidia_xxx=$(check_s_lst_pkg "${_nvidia_xxx[*]}") || _list_nvidia_lts_xxx=$(check_s_lst_pkg "${_nvidia_lts_xxx[*]}")
			wait
			clear
            [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} ${_list_nvidia_xxx[*]} 2>/tmp/.errlog \
            || pacstrap ${MOUNTPOINT} ${_list_nvidia_lts_xxx[*]} 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;            
        "10") # Via
			clear
			info_search_pkg
			_list_openchrome=$(check_s_lst_pkg "${_openchrome[*]}")
			wait
			clear
			[[ ${_list_openchrome[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_openchrome[*]} 2>/tmp/.errlog
             ;;            
        "11") # VirtualBox
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_VBoxInstTitle" --msgbox "$_VBoxInstBody" 0 0
            clear
			info_search_pkg
			[[ $LTS == 0 ]] && _list_vbox_pkg=$(check_s_lst_pkg "${_vbox_pkg[*]}") || _list_vbox_lts_pkg=$(check_s_lst_pkg "${_vbox_lts_pkg[*]}")
			wait
			clear
            [[ $LTS == 0 ]] && pacstrap ${MOUNTPOINT} ${_list_vbox_pkg[*]} 2>/tmp/.errlog \
            || pacstrap ${MOUNTPOINT} ${_list_vbox_lts_pkg[*]} 2>/tmp/.errlog
      
            # Load modules and enable vboxservice whatever the kernel
            arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"  
            arch_chroot "systemctl enable vboxservice"
            echo -e "vboxguest\nvboxsf\nvboxvideo" > ${MOUNTPOINT}/etc/modules-load.d/virtualbox.conf
             ;;
        "12") # VMWare
			clear
			info_search_pkg
			_list_vmware_pkg=$(check_s_lst_pkg "${_vmware_pkg[*]}")
			wait
			_clist_vmware_pkg=$(check_q_lst_pkg "${_list_vmware_pkg[*]}")
			wait
			clear
			[[ ${_clist_vmware_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_clist_vmware_pkg[*]} 2>/tmp/.errlog
             ;;
        "13") # Generic / Unknown
			clear
			info_search_pkg
			_list_generic_pkg=$(check_s_lst_pkg "${_generic_pkg[*]}")
			wait
			clear
			[[ ${_list_generic_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_generic_pkg[*]} 2>/tmp/.errlog
             ;;
          *) install_desktop_menu
             ;;
    esac
    check_for_error

 # Create a basic xorg configuration file for NVIDIA proprietary drivers where installed
 # if that file does not already exist.
 if [[ $NVIDIA_INST == 1 ]] && [[ ! -e ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf ]]; then
    echo -e -n "# /etc/X11/xorg.conf.d/20-nvidia.conf\n" > ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
	echo -e -n "Section \"Device\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\tIdentifier \"Nvidia Card\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\tDriver \"nvidia\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\tVendorName \"NVIDIA Corporation\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\tOption \"NoLogo\" \"true\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\t#Option \"UseEDID\" \"false\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\t#Option \"ConnectedMonitor\" \"DFP\"\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "\t# ...\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
    echo -e -n "EndSection\n" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
 fi
 
 # Where NVIDIA has been installed allow user to check and amend the file
 if [[ $NVIDIA_INST == 1 ]]; then
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_NvidiaConfTitle" --msgbox "$_NvidiaConfBody" 0 0
    nano ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
 fi

}


install_de_wm() {

   # Only show this information box once
   if [[ $SHOW_ONCE -eq 0 ]]; then
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DEInfoTitle" --msgbox "$_DEInfoBody" 0 0
      SHOW_ONCE=1
   fi
   
   if [[ $_d_menu_once == "0" ]]; then
		_d_menu_once=1
		clear
		info_search_pkg
		_list_d_menu=$(check_s_lst_pkg "${_d_menu[*]}")
		wait
		clear
		for i in ${_list_d_menu[*]}; do
			case $i in
				"cinnamon") _dm_desktop_menu="${_dm_desktop_menu} Cinnamon"
					;;
				"enlightenment") _dm_desktop_menu="${_dm_desktop_menu} Enlightenment"
					;;
				"gnome-shell") _dm_desktop_menu="${_dm_desktop_menu} Gnome-Shell_minimal"
					;;
				"gnome") _dm_desktop_menu="${_dm_desktop_menu} Gnome"
					;;
				"gnome-extra") _dm_desktop_menu="${_dm_desktop_menu} Gnome_Gnome-Extras"
					;;
				"plasma-desktop") _dm_desktop_menu="${_dm_desktop_menu} KDE5-Base_minimal"
					;;
				"plasma") _dm_desktop_menu="${_dm_desktop_menu} KDE5"
					;;
				"lxde") _dm_desktop_menu="${_dm_desktop_menu} LXDE"
					;;
				"lxqt") _dm_desktop_menu="${_dm_desktop_menu} LXQT"
					;;
				"mate") _dm_desktop_menu="${_dm_desktop_menu} MATE"
					;;
				"mate-extra") _dm_desktop_menu="${_dm_desktop_menu} MATE_MATE-Extras"
					;;
				"xfce4") _dm_desktop_menu="${_dm_desktop_menu} Xfce"
					;;
				"xfce4-goodies") _dm_desktop_menu="${_dm_desktop_menu} Xfce_Xfce-Extras"
					;;
				"awesome") _dm_desktop_menu="${_dm_desktop_menu} Awesome-WM"
					;;
				"fluxbox") _dm_desktop_menu="${_dm_desktop_menu} Fluxbox-WM"
					;;
				"i3-wm") _dm_desktop_menu="${_dm_desktop_menu} i3-WM"
					;;
				"icewm") _dm_desktop_menu="${_dm_desktop_menu} Ice-WM"
					;;
				"openbox") _dm_desktop_menu="${_dm_desktop_menu} Openbox-WM"
					;;
				"pekwm") _dm_desktop_menu="${_dm_desktop_menu} Pek-WM"
					;;
				"windowmaker") _dm_desktop_menu="${_dm_desktop_menu} WindowMaker-WM"
					;;
			esac
		done
		_list_dm_menu=""
		for i in ${_dm_desktop_menu[*]}; do
			_list_dm_menu="${_list_dm_menu} $i -"
		done
	fi
   
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDETitle" --menu "$_InstDEBody" 0 0 16 ${_list_dm_menu} 2>${ANSWER}
   
	#dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDETitle" \
    #--menu "$_InstDEBody" 0 0 11 \
 	#"1" $"Cinnamon" \
	#"2" $"Enlightenment" \
	#"3" $"Gnome-Shell (minimal)" \
	#"4" $"Gnome" \
	#"5" $"Gnome + Extras" \
    #"6" $"KDE 5 Base (minimal)" \
    #"7" $"KDE 5" \
    #"8" $"LXDE" \
    #"9" $"LXQT" \
    #"10" $"MATE" \
    #"11" $"MATE + Extras" \
    #"12" $"Xfce" \
    #"13" $"Xfce + Extras" \
    #"14" $"Awesome WM" \
    #"15" $"Fluxbox WM" \
	#"16" $"i3 WM" \
    #"17" $"Ice WM" \
    #"18" $"Openbox WM" \
    #"19" $"Pek WM" \
    #"20" $"WindowMaker WM" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "Cinnamon") # Cinnamon
             clear
			 info_search_pkg
			_list_cinnamon_pkg=$(check_s_lst_pkg "${_cinnamon_pkg[*]}")
			wait
			clear
			[[ ${_list_cinnamon_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_cinnamon_pkg[*]} 2>/tmp/.errlog
             ;;
        "Enlightenment") # Enlightement
             clear
			 info_search_pkg
			_list_enlightenment_pkg=$(check_s_lst_pkg "${_enlightenment_pkg[*]}")
			wait
			clear
			[[ ${_list_enlightenment_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_enlightenment_pkg[*]} 2>/tmp/.errlog
             ;;
        "Gnome-Shell_minimal") # Gnome-Shell
             clear
			 info_search_pkg
			 _list_gnome_shell_pkg=$(check_s_lst_pkg "${_gnome_shell_pkg[*]}")
			 wait
			 clear
			 [[ ${_list_gnome_shell_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_gnome_shell_pkg[*]} 2>/tmp/.errlog
             GNOME_INSTALLED=1
             ;;
        "Gnome") # Gnome
             clear
			 info_search_pkg
			_list_gnome_pkg=$(check_s_lst_pkg "${_gnome_pkg[*]}")
			wait
			clear
			[[ ${_list_gnome_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_gnome_pkg[*]} 2>/tmp/.errlog
           
             GNOME_INSTALLED=1
             ;;            
        "Gnome_Gnome-Extras") # Gnome + Extras
             clear
			 info_search_pkg
			_list_gnome_extras_pkg=$(check_s_lst_pkg "${_gnome_extras_pkg[*]}")
			wait
			clear
			[[ ${_list_gnome_extras_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_gnome_extras_pkg[*]} 2>/tmp/.errlog
           
             GNOME_INSTALLED=1
             ;;
        "KDE5-Base_minimal") # KDE5 BASE
             clear
			info_search_pkg
			_list_kde5base_pkg=$(check_s_lst_pkg "${_kde5base_pkg[*]}")
			wait
			clear
			[[ ${_list_kde5base_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_kde5base_pkg[*]} 2>/tmp/.errlog
             ;;
        "KDE5") # KDE5 
             clear
			 info_search_pkg
			_list_kde_pkg=$(check_s_lst_pkg "${_kde_pkg[*]}")
			wait
			clear
			[[ ${_list_kde_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_kde_pkg[*]} 2>/tmp/.errlog

             if [[ $NM_INSTALLED -eq 0 ]]; then          
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
                NM_INSTALLED=1
             fi
               
             KDE_INSTALLED=1
             ;;
         "LXDE") # LXDE
              clear
			  info_search_pkg
			  _list_lxde_pkg=$(check_s_lst_pkg "${_lxde_pkg[*]}")
			  wait
			  clear
			  [[ ${_list_lxde_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_lxde_pkg[*]} 2>/tmp/.errlog
              LXDE_INSTALLED=1
             ;;
         "LXQT") # LXQT
              clear
			  info_search_pkg
			_list_lxqt_pkg=$(check_s_lst_pkg "${_lxqt_pkg[*]}")
			wait
			clear
			[[ ${_list_lxqt_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_lxqt_pkg[*]} 2>/tmp/.errlog
              LXQT_INSTALLED=1
              ;;
         "MATE") # MATE
              clear
			  info_search_pkg
			_list_mate_pkg=$(check_s_lst_pkg "${_mate_pkg[*]}")
			wait
			clear
			[[ ${_list_mate_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_mate_pkg[*]} 2>/tmp/.errlog
             ;;
        "MATE_MATE-Extras") # MATE + Extras
               clear
			  info_search_pkg
			_list_mateextra_pkg=$(check_s_lst_pkg "${_mateextra_pkg[*]}")
			wait
			[[ ${_list_mateextra_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_mateextra_pkg[*]} 2>/tmp/.errlog
             ;;                 
        "Xfce") # Xfce
              clear
			  info_search_pkg
			_list_xfce4_pkg=$(check_s_lst_pkg "${_xfce4_pkg[*]}")
			wait
			clear
			[[ ${_list_xfce4_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_xfce4_pkg[*]} 2>/tmp/.errlog
             ;;            
        "Xfce_Xfce-Extras") # Xfce + Extras
              clear
			  info_search_pkg
			_list_xfce4_extra_pkg=$(check_s_lst_pkg "${_xfce4_extra_pkg[*]}")
			wait
			clear
			[[ ${_list_xfce4_extra_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_xfce4_extra_pkg[*]} 2>/tmp/.errlog
             ;;
        "Awesome-WM") # Awesome
              clear
			  info_search_pkg
			_list_awesome_pkg=$(check_s_lst_pkg "${_awesome_pkg[*]}")
			wait
			clear
			[[ ${_list_awesome_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_awesome_pkg[*]} 2>/tmp/.errlog
             ;;
        "Fluxbox-WM") #Fluxbox
              clear
			  info_search_pkg
			_list_fluxbox_pkg=$(check_s_lst_pkg "${_fluxbox_pkg[*]}")
			wait
			clear
			[[ ${_list_fluxbox_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_fluxbox_pkg[*]} 2>/tmp/.errlog
             ;; 
        "i3-WM") #i3
              clear
			  info_search_pkg
			_list_i3wm_pkg=$(check_s_lst_pkg "${_i3wm_pkg[*]}")
			wait
			clear
			[[ ${_list_i3wm_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_i3wm_pkg[*]} 2>/tmp/.errlog
             ;; 
        "Ice-WM") #IceWM
              clear
			  info_search_pkg
			_list_icewm_pkg=$(check_s_lst_pkg "${_icewm_pkg[*]}")
			wait
			clear
			[[ ${_list_icewm_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_icewm_pkg[*]} 2>/tmp/.errlog
             ;; 
        "Openbox-WM") #Openbox
              clear
			  info_search_pkg
			_list_openbox_pkg=$(check_s_lst_pkg "${_openbox_pkg[*]}")
			wait
			clear
			[[ ${_list_openbox_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_openbox_pkg[*]} 2>/tmp/.errlog
             ;; 
        "Pek-WM") #PekWM
              clear
			  info_search_pkg
			_list_pekwm_pkg=$(check_s_lst_pkg "${_pekwm_pkg[*]}")
			wait
			clear
			[[ ${_list_pekwm_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_pekwm_pkg[*]} 2>/tmp/.errlog
             ;;
        "WindowMaker-WM") #WindowMaker
             clear
			 info_search_pkg
			_list_windowmaker_pkg=$(check_s_lst_pkg "${_windowmaker_pkg[*]}")
			wait
			clear
			[[ ${_list_windowmaker_pkg[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_list_windowmaker_pkg[*]} 2>/tmp/.errlog
             ;;        
          *) install_desktop_menu
             ;;
    esac  
    
    check_for_error
}

# Determine if LXDE, LXQT, Gnome, and/or KDE has been installed, and act accordingly.
install_dm() {

# Function to save repetition
dm_menu(){

	#if [[ _dm_menu_once == 0 ]]; then
	#	_dm_menu_once=1
	#	clear
	#	info_search_pkg
	#	_list_dm_menu=$(check_s_lst_pkg "${_user_dm_menu[*]}")
	#	wait
	#	clear
	#	_listdm_menu=""
	#	for i in ${_list_dm_menu[*]}; do
	#		_listdm_menu="${_listdm_menu} $i -"
	#	done
	#fi
	
#	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" --menu "$_DmChBody" 0 0 5 ${_listdm_menu} 2>${ANSWER}
  dialog --default-item 3 --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" \
               --menu "$_DmChBody" 0 0 5 \
 	           "1" $"LXDM" \
	           "2" $"LightDM" \
	           "3" $"SDDM" \
			   "4" $"GDM" \
	           "5" $"SLiM" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") # LXDM
                   clear
				   info_search_pkg
					_list_lxdm_pkg=$(check_s_lst_pkg "${_lxdm_pkg[*]}")
					wait
					clear
                   pacstrap ${MOUNTPOINT} ${_list_lxdm_pkg[*]} 2>/tmp/.errlog
                   arch_chroot "systemctl enable lxdm.service" >/dev/null 2>>/tmp/.errlog
                   DM="LXDM"
                   ;;
              "2") # LIGHTDM
                   clear
				   info_search_pkg
					_list_lightdm_pkg=$(check_s_lst_pkg "${_lightdm_pkg[*]}")
					wait
					clear
                   pacstrap ${MOUNTPOINT} ${_list_lightdm_pkg[*]} 2>/tmp/.errlog
                   arch_chroot "systemctl enable lightdm.service" >/dev/null 2>>/tmp/.errlog
                   DM="LightDM"
                   ;;
              "3") # SDDM
                   clear
				   info_search_pkg
					_list_sddm_pkg=$(check_s_lst_pkg "${_sddm_pkg[*]}")
					wait
					clear
                   pacstrap ${MOUNTPOINT} ${_list_sddm_pkg[*]} 2>/tmp/.errlog
                   arch_chroot "sddm --example-config > /etc/sddm.conf"
                   arch_chroot "systemctl enable sddm.service" >/dev/null 2>>/tmp/.errlog
                   DM="SDDM"
                   ;;
			  "4") # GDM
					clear
					info_search_pkg
					_list_gdm_pkg=$(check_s_lst_pkg "${_gdm_pkg[*]}")
					wait
					clear
                   pacstrap ${MOUNTPOINT} ${_list_gdm_pkg[*]} 2>/tmp/.errlog
                   # arch_chroot "gdm --example-config > /etc/gdm.conf"
                   arch_chroot "systemctl enable gdm.service" >/dev/null 2>>/tmp/.errlog
                   DM="GDM"
					;;
              "5") # SLiM
                   clear
				   info_search_pkg
					_list_slim_pkg=$(check_s_lst_pkg "${_slim_pkg[*]}")
					wait
					clear
                   pacstrap ${MOUNTPOINT} ${_list_slim_pkg[*]} 2>/tmp/.errlog
                   arch_chroot "systemctl enable slim.service" >/dev/null 2>>/tmp/.errlog
                   DM="SLiM"

                   # Amend the xinitrc file accordingly for all user accounts
                   user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
				   for i in ${user_list[@]}; do
                       if [[ -n ${MOUNTPOINT}/home/$i/.xinitrc ]]; then
                          cp -f ${MOUNTPOINT}/etc/X11/xinit/xinitrc ${MOUNTPOINT}/home/$i/.xinitrc
	                      arch_chroot "chown -R ${i}:users /home/${i}"
	                   fi
                       echo 'exec $1' >> ${MOUNTPOINT}/home/$i/.xinitrc
                   done    
                   ;;                
                *) install_desktop_menu
                   ;;
            esac
}

 if [[ $DM_INSTALLED -eq 0 ]]; then
	     # Gnome without KDE
	     if [[ $GNOME_INSTALLED -eq 1 ]] && [[ $KDE_INSTALLED -eq 0 ]]; then
	        arch_chroot "systemctl enable gdm.service" >/dev/null 2>/tmp/.errlog
            DM="GDM"

         # Gnome with KDE
         elif [[ $GNOME_INSTALLED -eq 1 ]] && [[ $KDE_INSTALLED -eq 1 ]]; then   
             dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmChTitle" \
               --menu "$_DmChBody" 12 45 2 \
 	           "1" $"GDM  (Gnome)" \
	           "2" $"SDDM (KDE)" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") arch_chroot "systemctl enable gdm.service" >/dev/null 2>/tmp/.errlog
                   DM="GDM"
                   ;;
              "2") arch_chroot "sddm --example-config > /etc/sddm.conf"
                   arch_chroot "systemctl enable sddm.service" >/dev/null 2>>/tmp/.errlog
                   DM="SDDM"
                   ;;
                *) install_desktop_menu
                ;;
              esac    
              
         # KDE without Gnome      
        elif [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 0 ]]; then
	        arch_chroot "sddm --example-config > /etc/sddm.conf"
            arch_chroot "systemctl enable sddm.service" >/dev/null 2>>/tmp/.errlog
	        DM="SDDM"
            
         # LXDM, without KDE or Gnome 
         elif [[ $LXDE_INSTALLED -eq 1 ]] && [[ $KDE_INSTALLED -eq 0 ]] && [[ $GNOME_INSTALLED -eq 0 ]]; then 
            arch_chroot "systemctl enable lxdm.service" >/dev/null 2>/tmp/.errlog
            DM="LXDM"

         # Otherwise, select a DM	   
         else 
           dm_menu      
	     fi
	    
	    # Check installation success, inform user, and flag DM_INSTALLED so it cannot be run again
	    check_for_error
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " $DM $_DmDoneTitle" --msgbox "\n$DM $_DMDoneBody" 0 0
        DM_INSTALLED=1
         
  # if A display manager has already been installed and enabled (DM_INSTALLED=1), show a message instead.
  else  
         dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_DmInstTitle" --msgbox "$_DmInstBody" 0 0
  fi       

}

# General Menu Package

# back - install_desktop_menu
install_gep()
{
	if [[ $SUB_MENU != "general_package" ]]; then
	   SUB_MENU="general_package"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
	dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_menu_gen_title" --menu "$_menu_gen_body" 0 0 7 \
 	"1" "$_menu_gengen" \
	"2" "$_menu_archivers" \
	"3" "$_menu_ttf_theme" \
	"4" "$_menu_add_pkg" \
	"5" "$_menu_extra_pkg" \
	"6" "$_menu_pkg_meneger" \
	"7" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") install_gengen
         ;;
    "2") install_archivers
         ;;
	"3") install_ttftheme
         ;;
	"4") install_standartpkg
         ;;
	"5") install_otherpkg
         ;;
	"6") install_pm_menu
         ;;
      *) # Back to NAME Menu
		install_desktop_menu
         ;;
    esac
    
	check_for_error
	
    install_gep
}

install_shara_components()
{
	if [[ $_shara_p == "0" ]]; then
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_yesno_shara_title" --yesno "$_yesno_shara_body" 0 0
		if [[ $? -eq 0 ]]; then
			_shara_p=1
			clear
			info_search_pkg
			_list_network_pkg=$(check_s_lst_pkg "${_network_pkg[*]}")
			wait
			_clist_list_network_pkg=$(check_q_lst_pkg "${_list_network_pkg[*]}")
			wait
			clear
			pacstrap ${MOUNTPOINT} ${_clist_list_network_pkg[*]} 2>/tmp/.errlog
		fi
	fi
}

install_nm() {
   # Check to see if a NM has already been installed and enabled
   if [[ $NM_INSTALLED -eq 0 ]]; then
		if [[ $_nm_once == 0 ]]; then
			_nm_once=1
			clear
			info_search_pkg
			_list_network_menu=$(check_s_lst_pkg "${_network_menu[*]}")
			wait
			clear
			_ln_menu=""
			for i in ${_list_network_menu[*]}; do
				_ln_menu="${_ln_menu} $i -"
			done
			_ln_menu="${_ln_menu} dhcpcd -"
		fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMTitle" --menu "$_InstNMBody" 0 0 4 ${_ln_menu} 2>${ANSWER}
      #dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMTitle" \
      #--menu "$_InstNMBody" 0 0 4 \
 	  #"1" $"Connman (CLI)" \
	  #"2" $"dhcpcd  (CLI)" \
	  #"3" $"Network Manager (GUI)" \
	  #"4" $"WICD (GUI)" 2>${ANSWER}	
	
	  case $(cat ${ANSWER}) in
      "connman") # connman
           clear
			info_search_pkg
			_list_connman_pkg=$(check_s_lst_pkg "${_connman_pkg[*]}")
			wait
			clear
           pacstrap ${MOUNTPOINT} ${_list_connman_pkg[*]} 2>/tmp/.errlog
		   install_shara_components
           arch_chroot "systemctl enable connman.service" 2>>/tmp/.errlog
           ;;
      "dhcpcd") # dhcpcd
           clear
		   install_shara_components
           arch_chroot "systemctl enable dhcpcd.service" 2>/tmp/.errlog
           ;;
      "networkmanager") # Network Manager
           clear
		   info_search_pkg
			_list_net=$(check_s_lst_pkg "${_networkmanager_pkg[*]}")
			wait
			_clist_list_net=$(check_q_lst_pkg "${_list_net[*]}")
			wait
			_list_net_connect=$(check_s_lst_pkg "${_net_connect_var[*]}")
			wait
			_clist_list_net_conn=$(check_q_lst_pkg "${_list_net_connect[*]}")
			wait
			clear
			[[ ${_clist_list_net[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_clist_list_net[*]} 2>/tmp/.errlog
			[[ ${_clist_list_net_conn[*]} != "" ]] && pacstrap ${MOUNTPOINT} ${_clist_list_net_conn[*]} 2>/tmp/.errlog
		   install_shara_components
           arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" 2>>/tmp/.errlog
           ;;
      "wicd-gtk") # WICD
           clear
			info_search_pkg
			_list_wicd_pkg=$(check_s_lst_pkg "${_wicd_pkg[*]}")
			wait
			clear
           pacstrap ${MOUNTPOINT} ${_list_wicd_pkg[*]} 2>/tmp/.errlog
		   install_shara_components
           arch_chroot "systemctl enable wicd.service" 2>>/tmp/.errlog
           ;;
        *) install_desktop_menu
           ;;
      esac
      
      check_for_error
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMDoneTitle" --msgbox "$_InstNMDoneBody" 0 0
      NM_INSTALLED=1
   
   else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstNMDoneTitle" --msgbox "$_InstNMErrBody" 0 0
   fi
}


test() {
	
	ping -c 3 google.com > /tmp/.outfile &
    dialog --title "checking" --no-kill --tailboxbg /tmp/.outfile 20 60 

}

######################################################################
##																	##
##                 Swappiness config       							##
##																	##
######################################################################

# User installer to swappines parameters config

setswappiness()
{
	codes=""
	xcode=""
	cat /sys/fs/cgroup/memory/memory.swappiness 2> /dev/null 1> /dev/null
	codes=$?
	if [[ $codes == "0" ]]; then
		_swappiness=( $(cat /sys/fs/cgroup/memory/memory.swappiness) )
	elif [[ $codes != "0" ]]; then
		cat /proc/sys/vm/swappiness 2> /dev/null 1> /dev/null
		xcode=$?
		if [[ $xcode == "0" ]]; then
			_swappiness=( $(cat /proc/sys/vm/swappiness) )
		elif [[ $xcode != "0" ]]; then
			_swappiness="40"
		fi
	fi
	unset codes
	unset xcode
}
show_memory()
{
	echo -e -n "\n" > $_mem_file
	count=0
	for letter in "${_freefile[@]}"; do
		if [ "$count" -le 5 ]; then
			echo -e -n "\t$letter" >> $_mem_file
		elif [ "$count" -eq 6 ]; then
			echo -e -n "\n$letter" >> $_mem_file
		elif [ "$count" -eq 10 ]; then
			echo -e -n "\t  $letter" >> $_mem_file
		elif [ "$count" -eq 11 ]; then
			echo -e -n "\t     $letter" >> $_mem_file
		elif [ "$count" -eq 12 ]; then
			echo -e -n "\t    $letter" >> $_mem_file
		elif [ "$count" -le 12 ]; then
			echo -e -n "\t$letter" >> $_mem_file
		elif [ "$count" -eq 13 ]; then
			echo -e -n "\t\n$letter" >> $_mem_file
		elif [ "$count" -le 19 ]; then
			echo -e -n "\t$letter" >> $_mem_file
		fi
		let count+=1
	done
}
swappiness_info()
{
	echo -e -n "\n$_sw_nfo1\n" > $_mem_msg_file
	echo -e -n "$_sw_nfo2\n" >> $_mem_msg_file
	echo -e -n "$_sw_nfo3\n" >> $_mem_msg_file
	echo -e -n "$_sw_nfo4\n" >> $_mem_msg_file
	echo -e -n "$_sw_nfo5\n" >> $_mem_msg_file
	echo -e -n "$_sw_nfo6\n" >> $_mem_msg_file
	echo -e -n "\n$_sw_nfo7\n" >> $_mem_msg_file
	echo -e -n "\n$_sw_nfo8\n" >> $_mem_msg_file
}
show_mem()
{
	_freefile=( $(free -h) )
	IFS=$' '
	show_memory
	setswappiness
	echo -e -n "\n\n$_swap_frequency_info\n" >> $_mem_file
	echo -e -n "swappiness: $_swappiness\n" >> $_mem_file
	swappiness_info
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_msg_swps_title" --textbox $_mem_msg_file 0 0
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_free_info" --textbox $_mem_file 15 100
}
free_mem()
{
	rm -rf $_mem_file
	rm -rf $_mem_msg_file
	rm -rf $_File_of_Config
	unset freefile
	unset IFS
}
set_temp_swpns()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_input_swappiness_title" --inputbox "$_input_swappiness_body" 0 0 "" 2>${ANSWER}

	qst=$?
	case $qst in
		0) _swappiness=$(cat ${ANSWER})
			sysctl vm.swappiness=$_swappiness
			;;
	esac
}
set_swpns()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_input_swappiness_title" --inputbox "$_input_swappiness_body" 0 0 "" 2>${ANSWER}
	_swappiness=$(cat ${ANSWER})
	[ -e ${MOUNTPOINT}/etc/sysctl.d/ ] || mkdir ${MOUNTPOINT}/etc/sysctl.d/
	[[ ${_swappiness[*]} != "" ]] && echo "vm.swappiness=${_swappiness[*]}" > ${MOUNTPOINT}/etc/sysctl.d/00-sysctl.conf
}
swap_menu() {
	
	if [[ $SUB_MENU != "swap_menu" ]]; then
	   SUB_MENU="swap_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 4 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
   dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_swap_menu_title" \
    --menu "$_swap_menu_body" 0 0 4 \
 	"1" "$_sw_menu_info" \
	"2" "$_sw_menu_temp_swpns" \
	"3" "$_sw_menu_swpns" \
	"4" "$_Back"	2>${ANSWER}	
	variable=($(cat ${ANSWER}))
    case $variable in
        "1") show_mem
             ;;
        "2") set_temp_swpns
             ;;
		"3") set_swpns
			;;
        *) free_mem
			main_menu_online
             ;;
     esac	
     
    swap_menu
}	

######################################################################
##																	##
##                 Devices config       							##
##																	##
######################################################################

# User installer to device config parameters

select_mountpoint()
{
    devices_list=$(lsblk -l | sed '/SWAP/d' | grep -Ei "$1" | awk 'BEGIN{OFS=" "} {print $1,$4}')
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_sh_dev_title" --menu "$_sh_dev_body" 0 0 4 ${devices_list} 2>${ANSWER}
    DEVICES=$(cat ${ANSWER})
}
showmemory()
{
	if [[ $_once_shwram == "0" ]]; then
		rm -rf ${_mem_file}
		_freefile=( $(free -h) )
		IFS=$' '
		show_memory
		_once_shwram=1
	fi
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_free_info" --textbox ${_mem_file} 15 100
	clear
}
function reserved_block()
{
	_block_count=$(tune2fs -l $1 | grep -Ei "^(Block count:)" | sed 's/Block count://' | tr -d ' ')
	_reserved_block_count=$(tune2fs -l $1 | grep -Ei "^(Reserved block count:)" | sed 's/Reserved block count://' | tr -d ' ')
	bc=${_block_count[*]}
	unset _block_count
	rbc=${_reserved_block_count[*]}
	unset _reserved_block_count
	_reserv_procent=$(awk 'BEGIN{print ('"$rbc"'*100/'"$bc"')}' | sed 's/\./,/')
	unset bc
	unset rbc
	# round
	_rnd_reserv_procent=$(printf "%.0f" $_reserv_procent)
	unset _reserv_procent
	echo "${_rnd_reserv_procent[*]}"
}
show_block_info()
{
	deviceslist=$(lsblk -l | sed '/SWAP/d' | grep -Ei "${MOUNTPOINT}" | awk '{print $1}')
	echo "" > ${_rsrvd_file}
	for i in ${deviceslist[*]}; do
		devicessize=$(lsblk -l | sed '/SWAP/d' | grep -Ei "$i" | awk '{print $4}')
		_reserved_size=$(reserved_block "/dev/$i")
		echo -e -n "\n$_rsvd_nfo1 $i $_rsvd_nfo2 ${devicessize[*]} \n" >> ${_rsrvd_file}
		echo -e -n "$_rsvd_nfo3 $_reserved_size\n" >> ${_rsrvd_file}
	done
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_reserved_info_title" --textbox ${_rsrvd_file} 0 0
	clear
}
input_reserved_percentage()
{
	dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_input_reserved_title" --inputbox "$_input_reserved_body" 0 0 "" 2>${ANSWER}
	_isreserved=$(cat ${ANSWER})
}
fine_rsrvd_menu()
{
	rm -rf ${_rsrvd_file}
	rm -rf ${_mem_file}
	rm -rf ${_tmp_fstab}
	unset IFS
	unset freefile
}
rsrvd_menu()
{
	tmpfs_menu()
	{
		clear
		dialog --defaultno --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_rsrvd_menu3" --yesno "$_yesno_tmpfs_body" 0 0
		if [[ $? -eq 0 ]]; then
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_info_tmpfs_title" --msgbox "$_info_tmpfs_body" 0 0
			showmemory
			dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_input_size_tmpfs_title" --inputbox "$_input_size_tmpfs_body" 0 0 "" 2>${ANSWER}
			_size_tmpfs=$(cat ${ANSWER})
			sudo sed -i '/tmpfs/d' ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
			echo "tmpfs   /tmp         tmpfs   nodev,nosuid,size=${_size_tmpfs[*]}          0  0" >> ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
		fi
		clear
	}
	tmp_fstab_view()
	{
		cat /etc/fstab | grep -i "tmpfs" > ${_tmp_fstab}
		dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_rsrvd_menu3" --textbox ${_tmp_fstab} 0 0
	}
	tune2fs_menu()
	{
		clear
		select_mountpoint "${MOUNTPOINT}"
		input_reserved_percentage
		if [[ ${_isreserved[*]} -le 10 ]]; then
			if [[ ${_isreserved[*]} -ge 1 ]]; then
				sudo tune2fs -m ${_isreserved[*]} /dev/$DEVICES 2>/tmp/.errlog
				clear
			else echo "Error size paramter at 1 to 10" > /tmp/.errlog
			fi
		else echo "Error size paramter at 1 to 10" > /tmp/.errlog
		fi
	}
	if [[ $SUB_MENU != "rsrvd_menu" ]]; then
	   SUB_MENU="rsrvd_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_rsrvd_menu_title" --menu "$_rsrvd_menu_body" 0 0 5 \
 	"1" "$_rsrvd_menu1" \
	"2" "$_rsrvd_menu2" \
	"3" "$_rsrvd_menu3" \
	"4" "$_rsrvd_menu4" \
	"5" "$_Back" 2>${ANSWER} # $_Back
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") show_block_info
         ;;
    "2") tune2fs_menu
         ;;		
	"3") tmp_fstab_view
		;;
	"4") tmpfs_menu
		;;
      *) # Back to NAME Menu
		fine_rsrvd_menu
		main_menu_online
         ;;
    esac
	check_for_error
    rsrvd_menu
}


######################################################################
##																	##
##                 Main Interfaces       							##
##																	##
######################################################################

# Greet the user when first starting the installer
greeting() {

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_WelTitle $VERSION " --msgbox "$_WelBody" 0 0	

}

# Preparation
prep_menu() {
	
	if [[ $SUB_MENU != "prep_menu" ]]; then
	   SUB_MENU="prep_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi
	
   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_PrepTitle" \
    --menu "$_PrepBody" 0 0 7 \
 	"1" "$_ConfBseVirtCon" \
	"2" "$_PrepMirror" \
	"3" "$_DevShowOpt" \
	"4" "$_PrepPartDisk" \
	"5" "$_PrepLVM" \
	"6" "$_PrepMntPart" \
	"7" "$_Back" 2>${ANSWER}

    HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") set_keymap 
             ;;
        "2") configure_mirrorlist
             ;;
        "3") show_devices
             ;;
        "4") umount_partitions
             select_device
             create_partitions
             ;;
        "5") detect_lvm
             deactivate_lvm
             find_lvm_partitions
             create_lvm
             ;;
        "6") mount_partitions
             ;;        
          *) main_menu_online
             ;;
    esac
    
    prep_menu  	
	
}

# Base Installation
install_base_menu() {

	if [[ $SUB_MENU != "install_base_menu" ]]; then
	   SUB_MENU="install_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstBsMenuTitle" --menu "$_InstBseMenuBody" 0 0 5 \
 	"1" "$_PrepPacKey" \
 	"2" "$_InstBse" \
	"3" "$_InstBootldr" \
	"4" "$_InstWirelessFirm" \
	"5" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") clear
             pacman-key --init
             pacman-key --populate archlinux
             pacman-key --refresh-keys
             ;;
        "2") install_base
             ;;
        "3") install_bootloader
             ;;
        "4") install_wireless_firmware
             ;;
          *) main_menu_online
             ;;
     esac
    
    install_base_menu 	
}

# Base Configuration
config_base_menu() {
	
	# Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
	check_for_error
	
	if [[ $SUB_MENU != "config_base_menu" ]]; then
	   SUB_MENU="config_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfBseTitle" --menu "$_ConfBseBody" 0 0 7 \
 	"1" "$_ConfBseFstab" \
	"2" "$_ConfBseHost" \
	"3" "$_ConfBseTime" \
	"4" "$_ConfBseHWC" \
	"5" "$_ConfBseSysLoc" \
	"6" "$_PrepKBLayout" \
	"7" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") generate_fstab 
             ;;
        "2") set_hostname
             ;;
        "3") set_timezone
             ;;
        "4") set_hw_clock
             ;;            
        "5") set_locale
             ;;
        "6") set_xkbmap
             ;;           
          *) main_menu_online
             ;;
    esac
    
    config_base_menu

}

# Root and User Configuration
config_user_menu() {

	if [[ $SUB_MENU != "config_user_menu" ]]; then
	   SUB_MENU="config_user_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 3 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_ConfUsrTitle" --menu "$_ConfUsrBody" 0 0 3 \
 	"1" "$_ConfUsrRoot" \
	"2" "$_ConfUsrNew" \
	"3" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
    case $(cat ${ANSWER}) in
    "1") set_root_password 
         ;;
    "2") create_new_user
         ;;     
      *) main_menu_online
         ;;
    esac
    
    config_user_menu
}


install_desktop_menu() {

	if [[ $SUB_MENU != "install_deskop_menu" ]]; then
	   SUB_MENU="install_deskop_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 7 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_InstDEMenuTitle" --menu "$_InstDEMenuBody" 0 0 7 \
	"1" "$_AXITitle" \
 	"2" "$_GCtitle" \
	"3" "$_InstDEMenuDE" \
	"4" "$_InstDEMenuNM" \
	"5" "$_InstDEMenuDM" \
	"6" "$_InstGeMenuGE" \
	"7" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
		"1") [[ AXI_INSTALLED -eq 0 ]] && install_alsa_xorg_input
			;;
        "2") # _InstDEMenuGISD 
			setup_graphics_card 
             ;;
        "3") install_de_wm
             ;;
        "4") install_nm
             ;;
        "5") install_dm
             ;;
		"6") install_gep
			 ;;
          *) main_menu_online
             ;;
    esac
    
    install_desktop_menu
	
}


edit_configs() {
	
	# Clear the file variables
	FILE=""
	FILE2=""
	user_list=""
	
	if [[ $SUB_MENU != "edit configs" ]]; then
	   SUB_MENU="edit configs"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 11 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfOptTitle" --menu "$_SeeConfOptBody" 0 0 11 \
   "1" "/etc/vconsole.conf" \
   "2" "/etc/locale.conf" \
   "3" "/etc/hostname" \
   "4" "/etc/hosts" \
   "5" "/etc/sudoers" \
   "6" "/etc/mkinitcpio.conf" \
   "7" "/etc/fstab" \
   "8" "/etc/sysctl.d/00-sysctl.conf" \
   "9" "$BOOTLOADER" \
   "10" "$DM" \
   "11" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
	    "1") FILE="${MOUNTPOINT}/etc/vconsole.conf"
             ;;
        "2") FILE="${MOUNTPOINT}/etc/locale.conf" 
             ;;
        "3") FILE="${MOUNTPOINT}/etc/hostname"
             ;;
        "4") FILE="${MOUNTPOINT}/etc/hosts"
             ;;
        "5") FILE="${MOUNTPOINT}/etc/sudoers"
             ;;
        "6") FILE="${MOUNTPOINT}/etc/mkinitcpio.conf"
             ;;
        "7") FILE="${MOUNTPOINT}/etc/fstab"
             ;;
		"8") FILE="${MOUNTPOINT}/etc/sysctl.d/00-sysctl.conf"
			;;
        "9") case $BOOTLOADER in
                   "Grub") FILE="${MOUNTPOINT}/etc/default/grub"
                           ;;
               "Syslinux") FILE="${MOUNTPOINT}/boot/syslinux/syslinux.cfg"
                           ;;
           "systemd-boot") FILE="${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf" 
                           FILE2="${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf"
                           ;;
                 "rEFInd") [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf ]] \
                           && FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/refind/refind.conf" || FILE="${MOUNTPOINT}${UEFI_MOUNT}/EFI/BOOT/refind.conf"
                           FILE2="${MOUNTPOINT}/boot/refind_linux.conf"
                           ;;
              esac
            ;;
        "10") case $DM in
                   "LXDM") FILE="${MOUNTPOINT}/etc/lxdm/lxdm.conf" 
                           ;;
                "LightDM") FILE="${MOUNTPOINT}/etc/lightdm/lightdm.conf" 
                           ;;
                   "SDDM") FILE="${MOUNTPOINT}/etc/sddm.conf"
                           ;;
                   "SLiM") FILE="${MOUNTPOINT}/etc/slim.conf"
                           ;;
              esac
            ;;       
         *) main_menu_online
            ;;
     esac
     
        # open file(s) with nano   
        if [[ -e $FILE ]] && [[ $FILE2 != "" ]]; then
           nano $FILE $FILE2
        elif [[ -e $FILE ]]; then 
           nano $FILE
        else
           dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_SeeConfErrTitle" --msgbox "$_SeeConfErrBody1" 0 0
        fi
     
     edit_configs
}

main_menu_online() {
	
	if [[ $HIGHLIGHT != 10 ]]; then
	   HIGHLIGHT=$(( HIGHLIGHT + 1 ))
	fi
	
    dialog --default-item ${HIGHLIGHT} --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title "$_MMTitle" \
    --menu "$_MMBody" 0 0 10 \
 	"1" "$_MMPrep" \
	"2" "$_MMInstBse" \
	"3" "$_MMConfBse" \
	"4" "$_MMConfUsr" \
	"5" "$_MMInstDE" \
	"6" "$_swap_menu_title" \
	"7" "$_rsrvd_menu_title" \
    "8" "$_MMRunMkinit" \
    "9" "$_SeeConfOpt" \
	"10" "$_Done" 2>${ANSWER}

    HIGHLIGHT=$(cat ${ANSWER})
    
    # Depending on the answer, first check whether partition(s) are mounted and whether base has been installed
    if [[ $(cat ${ANSWER}) -eq 2 ]]; then
       check_mount
    fi

    if [[ $(cat ${ANSWER}) -ge 3 ]] && [[ $(cat ${ANSWER}) -le 7 ]]; then
       check_mount
       check_base
    fi
    
    case $(cat ${ANSWER}) in
        "1") prep_menu 
             ;;
        "2") install_base_menu
             ;;
        "3") config_base_menu
             ;;
        "4") config_user_menu
             ;;            
        "5") install_desktop_menu
             ;;
		"6") swap_menu
			;;
		"7") rsrvd_menu
			;;
        "8") run_mkinitcpio
             ;;
        "9") edit_configs
             ;;            
          *) dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --yesno "$_CloseInstBody" 0 0
          
             if [[ $? -eq 0 ]]; then
                umount_partitions
                clear
                exit 0
             else
                main_menu_online
             fi
             
             ;;
    esac
    
    main_menu_online 
    
}

######################################################################
##																	##
##                        Execution     							##
##																	##
######################################################################
# sudo cp -f $filesdir/pacman.conf /etc/pacman.conf
id_system
select_language
multilib_question
check_requirements
greeting
	while true; do
          main_menu_online      
    done
